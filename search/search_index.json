{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-it-do","title":"what it do","text":"<p>My \"blog\" project to publish my notes from studies on the Implementing Cisco Service Provider Advanced Routing Solutions v1.1 (SPRI 300-510) to re-certify my CCNP that expires soon.</p> <p>Ideally this will be a sub-project within a larger blog or website of my own. Much of it, the navigation, fonts, colors, and overall design are v0.1, and I don't really like it but I will focus on that later due to time crunch.</p>"},{"location":"BGP/","title":"Scaling BGP","text":""},{"location":"BGP/#route-reflectors-and-bgp-confederation-overview","title":"Route Reflectors and BGP Confederation Overview","text":"<ul> <li>The classic iBGP split horizon rule is that updates are received on a EBGP session should be forwarded on all iBGP and EBGP sessions, but updates that are received on an iBGP session should only be forwarded on EBGP sessions.</li> <li>The primary reason is to avoid routing loops, and it mandates the configuration of full mesh for iBGP neighbors inside an AS -- (n(n-1))/2 or 24 routers = (24(24-1))/2 = 276 sessions to configure. </li> <li>Each iBGP session is a TCP session to another iBGP peer, and updates sent to all iBGP peers could result in a significant amount of control plane TCP traffic</li> </ul>"},{"location":"BGP/#scalable-ibgp-solutions","title":"Scalable iBGP solutions","text":"<p>There are two solutions:</p> <ol> <li>Route reflectors -- these modify the split horizon rule, and they become a sort of \"BGP concentrator\"</li> <li>BGP confederations -- introduce the concept of various smaller AS's within the original AS, and the smaller AS's mainain intra-confederation EBGP sessions</li> </ol>"},{"location":"BGP/#design-guidelines","title":"Design guidelines","text":"<ul> <li> <p>Route reflectors </p> <ul> <li>are generally preferred by operators</li> <li>Usage: when there are more than 5 iBGP-speakers, which means practically the only except are multihomed enterprise networks with 1-3 edge routers</li> <li>Primary purpose: to reduce iBGP complexity and optimize performance</li> <li>Net effect: RR modify split-horizon rule to workaround full-mesh</li> </ul> </li> <li> <p>BGP confederations</p> <ul> <li>Usage: when a very large network consists of multiple administrative domains with differing route policies</li> <li>Primary purpose: to split a large network into smaller pieces to apply inbound and outbound policies at intra-confederation EBGP boundaries</li> <li>Net effect: BGP confederations modify iBGP AS-path processing </li> </ul> </li> </ul>"},{"location":"BGP/#bgp-split-horizon-rule-and-other-loop-prevention-mechanisms","title":"BGP Split-Horizon Rule and Other Loop-prevention Mechanisms","text":"<ul> <li> <p>The classic iBGP split horizon rule is that updates are received on a EBGP session should be forwarded on all iBGP and EBGP sessions, but updates that are received on an iBGP session should only be forwarded on EBGP sessions.</p> </li> <li> <p>For EBGP, AS Path is checked for the presence of the local AS to prevent routes from being re-injected</p> </li> </ul>"},{"location":"BGP/#modified-split-horizon-for-route-reflectors","title":"Modified split-horizon for Route Reflectors","text":"<ul> <li>Normal EBGP processing rules, routes from EBGP sessions are forwarded to any neighbor</li> <li>Routes from normal iBGP neighbors are sent to all iBGP clients and all EBGP peers.<ul> <li>NOTE: the default split-horizon rules apply to normal iBGP neighbors, but for iBGP clients of the RR, routes from iBGP neighbors are forwarded to iBGP clients</li> </ul> </li> <li>Routes from iBGP clients are sent to any neighbor to ensure that all other routes receive updates from clients who are assumed to not have any other iBGP neighborships apart from with the iBGP RR</li> </ul>"},{"location":"BGP/#bgp-loop-prevention-with-rr-cluster-id","title":"BGP Loop Prevention with RR-Cluster ID","text":"<ul> <li>Redundant RR can form a route reflector cluster. A BGP cluster ID (CID) is used to identify RR that form a cluster. </li> <li> <p>The CID is used for loop prevent-- when a route is reflected, the RR creates the BGP Cluster List attribute if it does not exist and adds or appends it's own CID to the list.</p> <ul> <li>If a route is received by a RR in the same cluster, it will block it similiar to AS Path loop prevention b/c the RR sees its own CID.</li> </ul> </li> <li> <p>The route reflector does not change the next-hop attribute or any common BGP attributes. </p> </li> <li> <p>Additionally, when a route is reflected, the RR sets the originator-ID BGP attribute to the router ID of the peer from which it received the route. Any router that receives a route with its own router ID in the originator-ID attribute silently ignores it.</p> </li> <li> <p>BGP best-path selection has some rules to include RR-related criteria. These tend to be low on the list, below preferring EBGP paths over iBGP paths</p> <ul> <li>When a router receives 2 iBGP paths, the nonreflected routes (with no Originator-ID) are preferred over reflected routes</li> <li>When a comparing reflected routes that are the same, shorter cluster lists are preferred</li> </ul> </li> </ul>"},{"location":"BGP/#more-on-bgp-rrs","title":"More on BGP RR's","text":"<ul> <li>Used to relay iBGP topology requirements</li> <li>All of the RR configuration is only done on RR<ul> <li>Configure which iBGP neighbors are clients</li> <li>Configure cluster ID if redundant</li> <li>Clients have normal iBGP neighbor config with RR</li> <li>RR are implemented on on per address family basis </li> </ul> </li> </ul>"},{"location":"BGP/#hierarchical-bgp-rrs","title":"Hierarchical BGP RR's","text":"<p>A network designer can use hierarchies for one RR cluster to act as a client in another cluster.</p> <p></p> <p>Clients of top RR cluster can be RR for lower level clients - Very useful in very large networks where one level of RR  - Each RR has its own unique cluster ID - Lower-level RR do not require a iBGP session between each other</p>"},{"location":"BGP/#configuring-rr","title":"Configuring RR","text":"IOS XE<pre><code>router# conf t\nrouter(config)# router bgp 64497\nrouter(config-router)# bgp cluster-id 10\nrouter(config-router)# address-family ipv4 unicast\nrouter(config-router)# neighbor 203.0.133.41 router-reflector-client\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router bgp 64497\nrouter(config-bgp)# bgp cluster-id 10\nrouter(config-bgp)# neighbor 203.0.133.41\nrouter(config-bgp-nbr)# address-family ipv4 unitcast\nrouter(config-bgp-nbr-af)# router-reflector-client\n</code></pre> <ul> <li>Verifying RR neighbor status <ul> <li>On both IOS XE/XR, in the <code>show bgp ipv4 neighbor</code> commands, there are lines indicating <code>Route-Reflector Client</code></li> <li>When looking at BGP routes, you can see <code>Originator:</code> and <code>Cluster life:</code> fields </li> </ul> </li> </ul>"},{"location":"BGP/#rr-guidelines","title":"RR Guidelines","text":"<p>When configuring RR, you must ensure the iBGP sessions between (if hierarchical) RR are configured properly, and that RR client sessions to iBGP clients are configured properly. Clients should should not sessions with other clients.</p> <p>Basically, do not misconfigure things. If hierarchical, you must ensure top-level RR cluster are peering with each other in iBGP full mesh. </p>"},{"location":"BGP/#bgp-confederations","title":"BGP Confederations","text":"<p>BGP confederations can be used to split a network into smaller networks where in/outbound policies or filters be be applied on intra-confederation EBGP boundaries. </p> <p>Commonly used to split very large networks along administrative boundaries. </p> <ul> <li>Each router must be aware of its real AS number to distinguish between external and intra-confederation EBGP sessions</li> <li> <p>Intra-confederation EBGP sessions behave almost like iBGP:</p> <ul> <li>Local preference, Next-hop, MED attributes are unchanged</li> <li>Only AS path attribute is modified with internal AS numbers</li> <li>Internal AS numbers are removed on external EBGP sessions</li> </ul> </li> <li> <p>Within the member AS or sub-AS's, iBGP rules still apply. So there must be full-mesh iBGP or RR's. </p> </li> </ul> IOS XE<pre><code>router# conf t\nrouter(config)# router bgp 65002\nrouter(config-router)# bgp confederation identifier 64998\nrouter(config-router)# bgp confederation peers 65001 65002 65003\n</code></pre> <ul> <li>The real AS number is 64998, while the intra-confederation AS number is 65002 above.</li> </ul> IOS XR<pre><code>router# conf t\nrouter(config)# router bgp 65001\nrouter(config-bgp)# bgp confederation identifier 64498\nrouter(config-bgp)# bgp confederation peers\nrouter(config-bgp-confed-peers)# 65001\nrouter(config-bgp-confed-peers)# 65002\nrouter(config-bgp-confed-peers)# 65003\n</code></pre> <p>When doing <code>show bgp ipv4 unicast 204.12.13.103</code> on IOS-XE, sub-AS numbers will be in parathenthis with a note about <code>confed-external</code></p> <p>On IOX-XR, <code>show bgp neighbor</code> will display <code>external link</code> + <code>neighbor under common admin</code>. These tell you it is an EBGP intra-confederation neighborship.</p>"},{"location":"ISIS/","title":"IS-IS","text":""},{"location":"ISIS/#interlevel-routing-and-is-is","title":"Interlevel Routing and IS-IS","text":"<ul> <li>Overall, IS-IS is a similiar link-state routing protocol with similiar issues and limitations</li> <li>When you have a single-level IS, the primary limit is the number of nodes</li> <li>Multilevel allows for less nodes for a smaller LSDB to scale</li> </ul> <p>NSAP Examples</p> <p>The NSAP 49.0001.aaaa.bbbb.cccc.00 consists of the following:</p> <ul> <li> <p>For IS-IS:</p> <ul> <li>Area = 49.0001</li> <li>System ID = aaaa.bbbb.cccc</li> <li>N-selector = 00</li> </ul> </li> <li> <p>For ISO-IGRP:</p> <ul> <li>Domain = 49</li> <li>Area = 0001</li> <li>System ID = aaaa.bbbb.cccc</li> <li>N-selector = ignored by ISO-IGRP</li> </ul> </li> </ul> <p>The NSAP 39.0f01.0002.0000.0c00.1111.00 consists of the following:</p> <ul> <li>For IS-IS:<ul> <li>Area = 39.0f01.0002</li> <li>System ID = 0000.0c00.1111</li> <li>N-selector = 00</li> </ul> </li> <li>For ISO-IGRP:<ul> <li>Domain = 39.0f01</li> <li>Area = 0002</li> <li>System ID = 0000.0c00.1111</li> <li>N-selector = ignored by ISO-IGRP</li> </ul> </li> </ul>"},{"location":"ISIS/#multilevel-is-is","title":"Multilevel IS-IS","text":"<p>Three types of routers:</p> <ol> <li> <p>Level 1 (L1): only learns about paths within the area they connect to (intra-area only) - edge/branch</p> </li> <li> <p>Level 2 (L2): learns about paths between area (inter-area) -- provider core</p> </li> <li> <p>Level 1-2 (L1-2): learn about paths both within and between areas. Similiar to OSPF ABR's.</p> </li> </ol> <p>Most notably, area boundaries fall on links. A router belongs in ONE level only.</p> <p>Adjancies are negotiated based on whether they are in the same area or a different area -&gt; L1, L2, or L1-2 neighborship</p> <p>By default, IS-IS areas are considered \"totally stubby\" by default, but you can leak L2 routes into L1</p>"},{"location":"ISIS/#configuring-multilevel-is-is-on-ios-xr","title":"Configuring Multilevel IS-IS on IOS-XR","text":"<ul> <li>Interfaces must be enabled for IS-IS, and the IS-type is Level1-2 by default. </li> <li>L2 used in core where there are only L2 link states exchanged IOS XR - P1 - net 49.0000 = area id (0)<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-isis)# net 49.0000.0001.0001.1001.00\nrouter(config-isis)# is-type level-2-only\nrouter(config-isis)# interface gi0/0/5/2\nrouter(config-isis-if)# ip router isis\nrouter(config-isis-if)# isis circuit-type level-2-only\n</code></pre> IOS XR - PE router - net 49.0002 = area id (2)<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-isis)# net 49.0002.0001.0001.1001.00\nrouter(config-isis)# is-type level-1-2\nrouter(config-isis)# interface gi0/0/0/1\nrouter(config-isis-if)# address-family ipv4 unicast\nrouter(config-isis-if)# isis circuit-type level-2-only\nrouter(config-isis)# interface gi0/0/0/2\nrouter(config-isis-if)# address-family ipv4 unicast\nrouter(config-isis-if)# isis circuit-type level-1-2\nrouter(config-isis)# interface gi0/0/0/3\nrouter(config-isis-if)# address-family ipv4 unicast\nrouter(config-isis-if)# isis circuit-type level-1\n</code></pre></li> <li>On the different interfaces, there will be different adjancies negotiated. <ul> <li>L2-only used in the core where only L2 LSP's are exchanged.</li> <li>L1-2 used with other L1-2 routers where both L1 and L2 LSP's are exchanged</li> <li>L1-only used with other L1-only routers to exchange only L1 LSP's</li> </ul> </li> </ul>"},{"location":"ISIS/#configuring-multilevel-is-is-on-ios-xe","title":"Configuring Multilevel IS-IS on IOS-XE","text":"<ul> <li>Generally it is the same as IOS-XR. Interfaces must be specifically enabled for IS-IS with the type selected</li> </ul> <p>IOS XE - P1 - net 49.0000 = area id (0)<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-router)# net 49.0000.0001.0001.1001.00\nrouter(config-router)# is-type level-2-only\nrouter(config-router)# exit\nrouter(config)# interface Gi0/1/5\nrouter(config-if)# ip router isis\nrouter(config-if)# isis circuit-type level-2-only\n</code></pre> IOS XE - PE - net 49.0002 = area id (2)<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-router)# net 49.0002.0001.0001.1001.00\nrouter(config-router)# is-type level-1-2\nrouter(config-router)# exit\nrouter(config)# interface Gi0/0/1\nrouter(config-if)# ip router isis\nrouter(config-if)# isis circuit-type level-2-only\nrouter(config-if)# exit\nrouter(config)# interface Gi0/0/2\nrouter(config-if)# ip router isis\nrouter(config-if)# isis circuit-type level-1-2\nrouter(config-if)# exit\nrouter(config)# interface Gi0/0/3\nrouter(config-if)# ip router isis\nrouter(config-if)# isis circuit-type level-1\n</code></pre></p>"},{"location":"ISIS/#is-is-route-leaking","title":"IS-IS Route Leaking","text":"<ul> <li>By default, routes are leaked from L1 to L2, but IS-IS will block L2 -&gt; L1</li> <li>You usually want to ensure that BGP next-hop addresses are reachable, so leaking these routes for reachability is important. </li> </ul> <p>IOS XE<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-router)# redistribute isis ip level-2 into level-1 route-map RM-ISIS\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-isis)# address-family ipv4 unicast\nrouter(config-isis-af)# propagate level 2 into level 1 route-policy RP-ISIS\n</code></pre></p>"},{"location":"ISIS/#prefix-suppression","title":"Prefix Suppression","text":"<ul> <li>Option to further limit the size of the LSDB. For example, to only advertise edge networks and BGP next-hop addresses. </li> <li>This can reduce the convergence time</li> <li>Commonly you would exclude transport links</li> <li> <p>If you configure interfaces to be passive in IS-IS, then only those interfaces with be propagated into IS-IS</p> </li> <li> <p>There are two ways to configure prefix suppression:</p> <ol> <li>On a per-interface basis</li> <li>On a per-router basis</li> </ol> </li> </ul> <p>IOS XE<pre><code>L1_L2-router# conf t\nL1_L2-router(config)# router isis 1\nL1_L2-router(config-router)# advertise passive-only\nOR\nL1_L2-router(config)# interface Gi0/2/1\nL1_L2-router(config-if)# no isis advertise-prefix\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-isis)# address-family ipv4 unicast\nrouter(config-isis-af)# advertise passive-only\nOR\nrouter(config-isis)# interface Gi0/0/1/2\nrouter(config-isis-if)# suppressed\n</code></pre></p> <ul> <li>Suppression = stops advertisement of PDU's over these links and also configures the IS-IS interface not to advertise its IP network to neighbors </li> </ul>"},{"location":"ISIS/#is-is-interlevel-routing-guidelines","title":"IS-IS Interlevel Routing Guidelines","text":"<ul> <li>Place a L1-2 border router between the core and POP uplink routers</li> <li>Use route leaking to ensure PE loopbacks are reachable and do not summarize</li> <li>Use prefix suppression to minimize LSDB size</li> </ul>"},{"location":"ISIS/#is-is-path-selection","title":"IS-IS Path Selection","text":"<ul> <li> <p>Similiar to OSPF, in a way.</p> </li> <li> <p>Level</p> <ul> <li>L1 route has highest preference</li> <li>L2 route as alternative</li> </ul> </li> <li>Paths of same level<ul> <li>Internal route has highest preference</li> <li>External route is alternative</li> </ul> </li> <li>For routes of the same level and origin:<ul> <li>Lowest metric</li> <li>All interfaces default to a metric of 10</li> </ul> </li> </ul>"},{"location":"ISIS/#configuring-is-is-metrics","title":"Configuring IS-IS Metrics","text":"<ul> <li>The IS-IS metric is similiar to OSPF, but there is no automatic mechanism for this to happen based on link bw. </li> <li>The default original metric is 1-63, while there is a wide configurable range between 1-16777214 after enabling <code>metric-style wide</code></li> </ul> <p>IOS XE<pre><code>L1_L2-router# conf t\nL1_L2-router(config)# router isis 1\nL1_L2-router(config-router)# metric-style wide\nL1_L2-router(config-router)# metric 15625000\nL1_L2-router(config-router)# exit\nL1_L2-router(config)# interface Gi0/5/1\nL1_L2-router(config-if)# isis metric 1000\n</code></pre> IOS XR<pre><code>L1_L2-router# conf t\nL1_L2-router(config)# router isis 1\nL1_L2-router(config-isis)# address-family ipv4 unicast\nL1_L2-router(config-isis-af)# metric-style wide\nL1_L2-router(config-isis-af)# metric 15625000\nL1_L2-router(config-isis-af)# exit\nL1_L2-router(config-isis)# interface Gi0/0/1/2\nL1_L2-router(config-isis-if)# metric 1000\n</code></pre></p>"},{"location":"ISIS/#is-is-path-selection-guidelines","title":"IS-IS Path Selection Guidelines","text":"<ul> <li>Use wide metric everywhere</li> <li>Change the default metric to a high value on slow interfaces from attracting traffic<ul> <li>Default is 10, lowest = best</li> </ul> </li> <li>Design a metric plan since there is no automatic metric calc in IS-IS</li> <li>Consider borrowing OSPF formula for link speeds and metrics</li> </ul>"},{"location":"ISIS/#is-is-summarization","title":"IS-IS Summarization","text":"<ul> <li>Solves large routing tables and frequent link-state flooding throughout the AS</li> <li>Reducing the size of database improves scalability</li> <li>By default, when a route flaps or disappears in one area, routers in other areas and levels get involved in SPF calculation</li> <li>Like OSPF, you can summarize routes but this is done on the Level boundaries in IS-IS, and they can be used with external redistributed routes</li> </ul> IOS XE<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-router)# redistribute ospf 1 level-1-2\nrouter(config-router)# summary-address 10.1.0.0 255.255.0.0 level-1\nrouter(config-router)# summary-address 10.2.0.0 255.255.0.0 level-2\nrouter(config-router)# summary-address 10.3.0.0 255.255.0.0 level-1-2\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-isis)# address-family ipv4 unicast\nrouter(config-isis-af)# redistribute ospf 1 level-1\nrouter(config-isis-af)# redistribute ospf 1 level-2\nrouter(config-isis-af)# summary-prefix 10.1.0.0/16 level-1 \nrouter(config-isis-af)# summary-prefix 10.2.0.0/16 level-2\nrouter(config-isis-af)# summary-prefix 10.3.0.0/16 level-1-2\n</code></pre> <ul> <li>This is a weird example, but it shows <code>summary-prefix</code> is used for IOS-XR and <code>summary-address</code> is used for IOS-XE with the different summary options:<ul> <li>level-1: only routes distributed into Level 1 are summarized</li> <li>level-1-2: summary routes applied when redistributed into Level 1 and 2 IS-IS, and when Level 2 \"leaks\" or advertises Level 1 routes as reachable</li> <li>level-2: routes learned by Level 1 routing are summarized into Level 2 backbone; redistributed external routes will also be summarized into Level 2 too.</li> </ul> </li> <li>Redueces the size of LSP's and thus the LSDB</li> <li>More stable because a summary advertisement depends on many specific routes, and as long as one of these specific routes is available, the summary route won't flap.</li> <li>Drawback is possibly less information to calculate the most optimal route in large topologies</li> </ul>"},{"location":"ISIS/#is-is-fast-convergence","title":"IS-IS Fast Convergence","text":"<ul> <li>By default, it can take IS-IS more than 30 seconds to converge upon link or device failure</li> <li>There are some techniques to improve this:<ol> <li>Tune IS-IS timers </li> <li>Cisco NSF</li> <li>Cisco NSR</li> <li>BFD</li> </ol> </li> </ul>"},{"location":"ISIS/#cisco-nsf-nsr","title":"Cisco NSF, NSR","text":"<ul> <li>More or less the same as NSF for OSPF</li> <li>Feature for IOS-XR to allow the forwarding of data packets to continue while protocol information is restored following a failover event between RP's on a NSF-capable router</li> <li>The standby RP during failover must relearn neighbor relationships and reacquire contents of LSDB's</li> <li>NSF-capable and NSF-aware neighbors do not flap during a RP failover using NSF</li> <li>NSR allows for RP failover, process restarts, and in-service upgrades to be invisible to peers.</li> <li>Using NSR alleviates the requirements for NSF and IETF graceful restart procotol extensions</li> </ul> <p>from a LLM about graceful restart protocol extensions:</p> <p>The IETF has defined graceful restart protocol extensions for IS-IS in RFC 5306. These extensions aim to minimize traffic loss and network disruption during a planned or unplanned IS-IS router restart. Here's how the IS-IS graceful restart mechanism works:</p> <ol> <li> <p>Graceful Restart Capability Advertisement:</p> <ul> <li>Routers advertise their support for graceful restart using the Graceful Restart TLV (Type-Length-Value) in their IS-IS Hello PDUs.</li> <li>The TLV includes information such as the restart duration (how long the restarting router will take to complete the restart) and the restart reason (planned or unplanned).</li> </ul> </li> <li> <p>Planned Restart:</p> <ul> <li>When a router undergoes a planned restart (e.g., for software upgrade), it sends IS-IS Hello PDUs with the Graceful Restart TLV to its neighbors, indicating its intention to restart.</li> <li>The restarting router's neighbors (helper routers) will continue to advertise the restarting router's routes as if it were still active, using the restart duration advertised in the Graceful Restart TLV.</li> </ul> </li> <li> <p>Unplanned Restart:</p> <ul> <li>If a router experiences an unplanned restart (e.g., due to a crash), it will not have the opportunity to send the Graceful Restart TLV in advance.</li> <li>Upon restart, the router will send IS-IS Hello PDUs with the Graceful Restart TLV, indicating that it has just restarted and is in the process of recovering its state.</li> </ul> </li> <li> <p>Helper Router Behavior:</p> <ul> <li>Neighbors of the restarting router (helper routers) will continue to advertise the restarting router's routes for the duration specified in the Graceful Restart TLV.</li> <li>Helper routers will mark the restarting router's routes as \"stale\" but will continue to forward traffic to those routes.</li> <li>If the restarting router does not re-establish adjacency within the specified restart duration, the helper routers will remove the stale routes.</li> </ul> </li> <li> <p>Restarting Router Recovery:</p> <ul> <li>During the restart, the restarting router will rebuild its routing table and LSDB (Link State Database) based on the information received from its neighbors.</li> <li>Once the restarting router has rebuilt its state, it will send updated LSPs (Link State PDUs) to its neighbors, indicating that it has completed the restart process.</li> </ul> </li> <li> <p>Synchronization and Convergence:</p> <ul> <li>Upon receiving the updated LSPs from the restarting router, the helper routers will synchronize their LSDBs with the restarting router.</li> <li>The network will converge, and normal IS-IS routing will resume.</li> </ul> </li> </ol> <p>The IS-IS graceful restart mechanism helps minimize traffic disruption during router restarts by allowing the restarting router's neighbors to continue forwarding traffic to the restarting router's routes while it rebuilds its state. This provides a smoother transition and faster convergence compared to a complete network reconvergence.</p>"},{"location":"ISIS/#other-factors-affecting-convergence","title":"Other factors affecting convergence","text":"<ul> <li>Not all underlying physical topologies support fast link failure notifications</li> <li>carrier delays could introduce additional delay</li> <li>slower timers could yield a more stable environment at the expense of faster convergence</li> </ul>"},{"location":"ISIS/#is-is-events-influencing-convergence","title":"IS-IS events influencing convergence","text":"Event Action Timers Default Timer Local LSP change Originate LSP and flood LSP generation timer 5 seconds LSP db and tree change Run iSPF/SFP calculation SFP interval 10 seconds LSP db but no tree change Run PRC calculation PRC interval 5 seconds Scheduled Periodic LSP flooding LSP refresh interval 900 seconds (15mins) LSP expires LSP refreshing Max LSP lifetime 1200 seconds Pace LSPs (30 LSP/s) LSP flooding LSP interval 33ms LSP interval Run iSPF/SPF and flood LSP CPU-related delays trigger SPF early -"},{"location":"ISIS/#lsp-processing-and-propagation","title":"LSP Processing and Propagation","text":"<p>ISO 10589 states LSP flooding is limited to 30 LSP's per second There are design suggestions to improve LSP processing:</p> <ol> <li>Reduce the gap to speed up end-to-end flooding</li> <li>Reduce unnecessary control plane traffic to converse CPU for LSP's</li> <li>Reduce the frequency of periodic LSP flooding to reduce link utilization</li> <li>Ignore LSP's with bad checksum instead of purging</li> </ol> <p>Throttling slows convergence, but it prevents \"meltdown\" that would cause further problems. The goal is to react fast to the first events but, under constant churn, slow down to avoid collapse.</p> <ul> <li>During convergence, IS-IS throttles the following events:<ul> <li>SPF computation<ul> <li>IS-IS throttles SPF calculation to prevent excessive CPU</li> <li>When there is a LSP upgrade to trigger SPF calc, IS-IS starts a SFP timer</li> <li>If additional LSP updates are rx'd during this timer, IS-IS will wait until timer completes before running SPF, incorporating all the changes</li> </ul> </li> <li>LSP generation<ul> <li>when there is an event that triggers generating a new LSP, this starts the generation timer and hold-down timers</li> <li>if additional triggering events IS-IS occur during the hold-time timer, IS-IS will wait for the generation timer to expire before generating a new LSP, incorporating all the changes        </li> </ul> </li> <li>Partial route calculation (PRC) computation<ul> <li>Similiar as above  <p>PRC is the software\u2019s process of calculating routes without performing an shortest path first (SPF) calculation. This is possible when the topology of the routing system itself has not changed, but a change is detected in the information announced by a particular IS or when it is necessary to attempt to reinstall such routes in the Routing Information Base (RIB).</p> </li> </ul> </li> </ul> </li> </ul>"},{"location":"ISIS/#carrier-delay","title":"Carrier Delay","text":"<ul> <li>If a link goes down and up before the carrier delay expires, then the down state event is filtered</li> <li>Higher delay = more stability; while setting to 0 delay = everything is detected</li> <li>Most environments want low or default carrier delays, but if there tends to be a high frequency of small outages, then it might be prudent to not cause disruptions and trigger re-convergence</li> <li>If there are rare but long outages, short delay or 0 delay better</li> </ul>"},{"location":"ISIS/#configuring-is-is-for-fast-convergence","title":"Configuring IS-IS for Fast Convergence","text":"<p>IOS-XE only example:</p> <p>Look at Cisco IOS IP Routing: ISIS Command Reference for additional info on each of these...</p> IOS XE<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-router)# bfd all-interfaces\nrouter(config-router)# fast-flood 15  # send 15 LSP's before running SPF, default = 5\nrouter(config-router)# isis lsp-interval 10  # reduces LSP interval, default 33ms\nrouter(config-router)# max-lsp-lifetime 65535  # LSP lifetime up from default 1200s\nrouter(config-router)# lsp-refresh-interval 65000  # up from default 900s\nrouter(config-router)# ignore-lsp-errors\nrouter(config-router)# spf-interval 5 1 20  # default is 10s 5.5s 5500ms    \\\nrouter(config-router)# prc-interval 5 1 20  # default is 10s 5.5s 5500ms     |- these 3 are backoff timers\nrouter(config-router)# lsp-gen-interval 5 1 20  # default is 5s 50ms 5000ms /\nrouter(config-router)# ispf level-1-2 60  # incremental SPF calc timer\nrouter(config-router)# no hello padding\nrouter(config)# interface gi1/0/1\nrouter(config-if)# bfd interval 50 min_rx 50 multiplier 5  # fast link detected via BFD\nrouter(config-if)# isis network point-to-point  # disable DIS election\nrouter(config-if)# carrier-delay down msec 0  # immediate down notification\nrouter(config-if)# carrier-delay up 2  # delayed link-up notification\n</code></pre> <p>Regarding <code>ispf</code>:</p> <p>When changes to a Type 1 or Type 2 link-state advertisement (LSA) occur in an area, the entire SPT is recomputed. In many cases, the entire SPT need not be recomputed because most of the tree remains unchanged. Incremental SPF allows the system to recompute only the affected part of the tree. Recomputing only a portion of the tree rather than the entire tree results in faster OSPF convergence and saves CPU resources. </p>"},{"location":"ISIS/#isis-convergence-guidelines","title":"ISIS Convergence Guidelines","text":"<ul> <li>Set goals and also account for other protocol options like MPLS TE like Fast Reroute </li> <li>Suggestions:<ul> <li>Use BFD over faster hellos</li> <li>Consider carrier delay to minimize process times</li> <li>Use p2p mode on core links to avoid DIS election</li> <li>Tune timers to improve process/flooding LSPs</li> </ul> </li> </ul>"},{"location":"ISIS/#is-is-for-ipv6","title":"IS-IS for IPv6","text":"<ul> <li> <p>Multiprotocol by default, supports both IPv4 and IPv6 wiwth multitopology support to allow IS-IS to maintain a set of independent topologies within a single area or domainq</p> <ul> <li>Not all routers inside the IS-IS domain need to all be dual-stack. The topologies are separate, SPF is calculated for each independently.</li> <li>For multitopology support, all routers in the domain should be multitopology enabled</li> </ul> </li> <li> <p>On IOS-XE/XR, one must use <code>metric-style wide</code> to configure new-style TLV's for IPv6 info in LSP's when using multitopology </p> </li> <li>when you migrate from pure-IPv4 to dual-stack, there is the <code>adjacency-check disable</code> (IOSXE) or <code>no adjacency-check</code> configuration to disable consistency checks on hello packets to allow a router running IS-IS for both IPv4 and IPv6 to form an adjacency with a router running IS-IS for IPv4 or IPv6 only.</li> </ul>"},{"location":"ISIS/#configuring-is-is-for-ipv6","title":"Configuring IS-IS for IPv6","text":"IOS XE<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-router)# metrics-style wide\nrouter(config-router)# address-family ipv6 unicast\nrouter(config-router)# exit\nrouter(config)# int Gi1/0/1\nrouter(config-if)# ipv6 enable\nrouter(config-if)# ipv6 router isis\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-isis)# address-family ipv6 unicast\nrouter(config-isis-af)# single-topology         # IOS-XR is multi-topology by default\nrouter(config-isis-af)# exit\nrouter(config-isis)# int Te1/0/3 \nrouter(config-isis-if)# address-family ipv6 unicast\nrouter(config-isis-if)# exit\nrouter(config-isis)# int Te1/0/4\nrouter(config-isis-if)# address-family ipv6 unicast\n</code></pre>"},{"location":"ISIS/#route-summarization-for-ipv6","title":"Route Summarization for IPv6","text":"<ul> <li>Both IOSXE/XR use <code>summary-prefix</code> for summarization of IPv6 prefixes, everything else for route summarization is the same as in IPv4 described earlier</li> </ul>"},{"location":"ISIS/#is-is-v-ospf-comparisons","title":"IS-IS v OSPF Comparisons","text":"<ul> <li> <p>Both are link-state protocols with similiar characteristics (different terminology sometimes), but there are large design differences:</p> <ul> <li>OSPF, different interfaces can be in different areas, while in IS-IS, the router itself is assigned into an area. </li> <li>IS-IS is not constrained to using a backbone area, so there can be more flexibility to modify topology</li> </ul> </li> <li> <p>IS-IS has a heirarchy of Level-1, Level-2, and L1-L2 routers, and the area borders are on links (as the routers themselves are only in one area)</p> </li> <li> <p>OSPF can produce many small LSA's, while IS-IS updates can be grouped and sent as one LSP</p> <ul> <li>This can add up to be a large \"pro\" for why IS-IS can be more scalable in single-area designs over OSPF</li> </ul> </li> <li> <p>OSPF runs on top of IP, while IS-IS uses Connectionless Network Service (CLNS) that is a L2 protocol. </p> </li> <li> <p>IS-IS is also more efficient than OSPF in the use of CPU resources in how it processes routing updates due to less LSPs</p> </li> <li> <p>OSPF schema to add new features with LSA's is challenging due to compatability issues, while IS-IS is easy to extend through the TLV extension</p> </li> </ul>"},{"location":"ISIS/#comparing-ospf-and-is-is-terminology","title":"Comparing OSPF and IS-IS terminology","text":"Terminology OSPF IS-IS Node Router IS Link Link Circuit Multiaccess node DR DIS Redundant Multiaccess node BDR n/a Routing update link-state advertisement (LSA) link-state PDU (LSP) Keepalive Hello packet IS-IS Hello (IIH PDU) Area Area Subdomain or area Inter-area nodes ABR Level 1 Level 2 IS Node identifier Router ID System ID Characteristic OSPF IS-IS Transport protocol IP CLNS Node identifier IPv4 (router ID) NSAP (system ID) Area boundary Node: ABR in multiple areas / Link in one area Link: Level 1 Level 2 router in one area / link in multiple areas Link in two areas/levels Virtual Link Level 1 Level 2 link Multiprotocol No Yes High availability DR and BDR Only one DIS Automatic cost Yes No"},{"location":"MPLS%20LDP/","title":"Implementing and Verifying MPLS","text":""},{"location":"MPLS%20LDP/#mpls-forwarding-structures","title":"MPLS Forwarding Structures","text":"<p>MPLS adds two functions to an IP network: Label Distribution Protocol (LDP) to exchange labels between routers and a Label Forwarding Information Base (LFIB) to enable routers to forward packets based on their labels in received packets. </p> <p>Similiar to how OSPF -&gt; RIB -&gt; FIB, there is LDP -&gt; LIB -&gt; LFIB.</p> <p>However, for MPLS to work well, you'll need the whole \"SP\" stack, with an IGP and BGP to built the control plane</p> <p>Some control plane functions within MPLS:</p> <ul> <li>Either IS-IS or OSPF are used to provide reachability within the AS. </li> <li>BGP is used to carry all other routes, such as customer or Internet routing info. MP-BGP can also carry info for non-IP solutions or implement VPN's</li> <li>LDP is used to exchange labels for routes learned via the IGP, which enables all destinations in the AS to be reachable with a label switched path (LSP). A LSP is built for every destination based on IGP determined path.</li> <li>Resource Reservation Protocol (RSVP) is used with MPLS TE to build LSPs that may diverge from the IGP-determined shortest path in order to improve utilization (reduce congestion) or provide QoS for diff types of traffic.</li> </ul> <p>Some data plane functions within MPLS:</p> <ul> <li> <p>Based on the contents of the FIB for a route lookup, a router will perform two different forwarding functions:</p> <ol> <li>Ingress Edge Label Switched Router (LSR)-- if the route in the FIB has a stack of labels associated with it, the packet will be sent as a labeled packet</li> <li>If the route has no label, the router will perform normal IP forwarding </li> </ol> </li> <li> <p>A router makes label forwarding decisions based on the top label in the stack between the L2 and L3 headers. This is the LFIB, and based on the contents of the matching route, a router will do:</p> <ol> <li>Core LSR: if the top label is mapped to a next-hop label, the router will replace the top label and the labeled packet will be forwarded</li> <li>Egress edge LSR: upon examination of the top level label, if there is no next-hop label, the router will remove the label and (optionally) perform an IP lookup and forward the IP packet</li> </ol> </li> </ul>"},{"location":"MPLS%20LDP/#label-distribution-protocol","title":"Label Distribution Protocol","text":"<p>LDP is responsible for populating labels or the forwarding structures used by MPLS.</p> <p>FIB == destination networks, next-hops, outgoing interfaces, and L2 pointers is populated from the RIB and ARP cache. The RIB is populated by routing protocols.</p> <p>Also, the MPLS label is added to destination networks if outgoing interface is enabled for MPLS and a label has been received from the next-hop router. LDP adds the label to FIB entries, creating the LFIB with locally assigned (incoming) and received from next-hop (outgoing) labels. </p>"},{"location":"MPLS%20LDP/#label-switched-path","title":"Label switched path","text":"<p>An LSP is a sequence of Label Switched Routers (LSR) that forward labeled packets for a specific Forwarding Equivalence Path (FEC). Each intermediate LSR along the path swaps label along the LSP.</p> <p>A FEC is a group of packets that are forwarded along the same path and get the same forwarding treatment.</p> <p>So in MPLS unicast forwarding, the FEC's are deteremined by destination networks found in main routing table, and a LSP is created for each entry. </p> <p>There is an exception for BGP-derived routes. There is a shared label for all BGP routes that share the same next-hop address. All of the core (P) routers run an IGP to learn BGP next-hops. So an IGP populates the routing table in all MPLS routers, then LDP propagates labels for these IGP learned networks to build LSPs.</p> <ul> <li>LSP's are unidirectional. </li> <li>They are built using: (1) IGP to determine shortest path, (2) LDP to allocate and exchange labels</li> </ul> <p></p>"},{"location":"MPLS%20LDP/#label-allocation-and-distribution","title":"Label Allocation and Distribution","text":"<ol> <li>IP routing protocols build the IP routing table</li> <li>Each LSR assigns a label (local labels) to every destination in the RIB except for BGP-learned routes for which the label for the next-hop is reused</li> <li>LSRs announce their assigned labels to all other LSRs</li> <li>Every LSR builds its LIB, LFIB, and FIB data structures based on received labels and chosen best paths</li> </ol> <p>MPLS uses a liberal label retention mode, which means it will keep labels received LDP peers, even if they are not received from LDP peers even if they are not actively used.</p> <p>The LSR's stores labels and related information inside the LIB. This is the control plane for LDP. A route prefix is assigned a locally significant label, which is mapped to a next-hop label learned from downstream neighbor.</p> <p>The LFIB contains local labels (which are advertised to upstream neighbors) mapped to next-hop labels, which are received from downstream neighbors. </p> <p>MPLS routers locally allocate labels, independently and asynchronously. </p> <p>On the edge LSR, next-hops outside the MPLS domain are not assigned a label. Instead, the <code>pop</code> or implicit null label is advertised, which instructs the penultimate router to remove the label when forwarding packets to the egress router. This is the penultimate-hop popping (php).</p> <p>Label advertisement:</p> <p>[<code>A</code> Edge LSR] - [<code>B</code> LSR ] - [<code>C</code> LSR ] -- [<code>D</code> Edge LSR]- (network 12.0.0.0/8)</p> <ol> <li> <p>Router <code>B</code> allocates label 25 for network 12.0.0.0/8. The label is stored in <code>B</code> LIB. It is stored as an incoming label in the LFIB. There is no outgoing label for network 12.0.0.0/8 from next-hop router <code>C</code>. Label 25 is advertised to neighbors <code>A</code> and <code>C</code>, regardless of whether or not the neighbor is a next-hop for a destination.</p> </li> <li> <p>Router <code>A</code> allocates label 21 for network 12.0.0.0/8. Label 21 is stored in the LIB and LFIB as incoming label, while label 25 is stored as outgoing label in LFIB and FIB. </p> </li> <li> <p>Router <code>C</code> allocates label 34 for network 12.0.0.0/8. It is stored in the LIB and LFIB as incoming label, then advertised to <code>B</code> and <code>D</code>. Router <code>C</code> also receives a label for 12.0.0.0/8 from router <code>B</code>, even though it is not the next-hop and stores it in the LIB.</p> </li> <li> <p>Router <code>B</code> gets label 34 from <code>B</code> for network 12.0.0.0/8 and stores it in the LIB. Label 34 is the next-hop for destination 12.0.0.0/8, so it is also stored in LFIB as outgoing label. Router <code>B</code> also sets label 34 for 12.0.0.0/8 in FIB b/c this label is from the next-hop.</p> </li> <li> <p>Then on router <code>D</code>, it allocates implicit null for network 12.0.0.0/8, as it is outside the MPLS domain. This implicit null label is also advertised to router <code>C</code> to perform label removal (pop) operation.</p> </li> <li> <p>Router <code>C</code> receives this implicit null label from <code>D</code> and stores it in LIB. This is from the next-hop for 12.0.0.0/8, router <code>C</code> also stores the implicit null label in LFIB as outgoing label. The label for 12.0.0.0/8 to <code>D</code> is also stored in the FIB on router <code>C</code>.</p> </li> </ol> <p>The LSP for 12.0.0.0/8 through A-&gt;B-&gt;C-&gt;D is established. </p> <p>So for packet propagation through this LSP, it works like:</p> <ol> <li> <p>Router <code>A</code> receives packet destinationed to 12.0.0.0/8. FIB lookup resolves to label 25, which is switched via CEF.</p> </li> <li> <p>Router <code>B</code> receives a packet with a label 25, so LFIB lookup maps incoming label 25 to outgoing label 34 with next-hop router <code>C</code>. This is label-switched via LFIB.</p> </li> <li> <p>Router <code>C</code> receives a packet with label 34. LFIB maps incoming label 34 to outgoing implicit null to next-hop router <code>D</code>. Router <code>C</code> pops the label and forwards the packet to router <code>D</code> by label-switching via LFIB.</p> </li> <li> <p>Router <code>D</code> performs an IP lookup in FIB table to forward packet to destination 12.0.0.0/8.</p> </li> </ol> <p>The PHP or pop with implicit null is the default behavior on Cisco MPLS-enabled routers. If you use <code>explicit null</code>, then there is an additional LFIB lookup on router <code>D</code>. Starting from step 3 above where router <code>D</code> advertised label 47 for 12.0.0.0/8.</p> <ol> <li> <p>Router <code>C</code> receives a packet with label 34. LFIB maps incoming label 34 to outgoing label 47 with next-hop router <code>D</code>. This is label-switched via LFIB.</p> </li> <li> <p>Router <code>D</code> receives packet with lavel 47. LFIB lookup maps incoming label 47 to pop to remove the label, then a FIB lookup for an IP lookup to forward packet to destination 12.0.0.0/8 occurs.</p> </li> </ol>"},{"location":"MPLS%20LDP/#the-mpls-steady-state-condition","title":"The MPLS Steady State condition","text":"<p>*Steady State is when all labels are exchanged and the LIB, LFIB, and FIB structures are completely populated. </p> <ul> <li>It takes longer for LDP to exchange labels compared to routing protocol convergence</li> <li>There is no network downtime while LDP exchanges labels since packets can route using the FIB and IP lookups</li> <li>Then once steady state is reached, all packets are label-switched (faster, cheaper), except on ingress and egress edge LSR.</li> </ul>"},{"location":"MPLS%20LDP/#mpls-label-control-methods","title":"MPLS label control methods","text":"<p>This is label filtering in LDP. There is incoming and outgoing filtering.</p> <ol> <li>Outgoing is known as Label Advertisement Control or outbound label filtering. </li> <li>Incoming is known as Label Acceptable Control or inbound label filtering.</li> </ol> <p>Both of these are used to improve scabability and memory-usage or security reasons. </p> <p>Inbound label filtering potentially overrides the default behavior to keep remote label binding from all LDP peers for a given prefix, even if the LDP peer is not the next-hop.</p>"},{"location":"MPLS%20LDP/#gotchas-with-route-summarization-aggregation","title":"Gotchas with route summarization, aggregation","text":"<p>You can have route information for a /24 and then an aggregate /16. MPLS will build LSP's for both routes, and depending on where the summarization boundary is, this can result in an early pop then re-labeling on the next-hop router.</p> <p>This should not be an \"issue\" for the router at the summarization boundary has more specific routes, but if this router does not (like a P router that likely won't have full tables for IP transit or if it has services like MPLS-based VPNs), then these services will fail due to missing routing info or info on the second-layer of MPLS labels. </p> <p>So, IGP summarization likely should not be used where:</p> <ul> <li>MPLS VPNs</li> <li>MPLS TE</li> <li>Transit BGP where core routers are not running BGP</li> </ul>"},{"location":"MPLS%20LDP/#mpls-forwarding-operations","title":"MPLS Forwarding Operations","text":"<p>Let's look at the forwarding specifics now...</p> <p>For review, MPLS adds functionality to the normal IP forwarding by:</p> <ul> <li>LDP in control plane to allocate and exchange labels</li> <li>LFIB is used to forward labeled packets</li> <li>FIB table labels IP packets if the next-hop has a label assigned to it</li> </ul> <p>By default, IP forwarding without labels works like:</p> <p>A BGP route is inserted into the RIB. OSPF is used to resolve the IP next-hop address used by BGP. The OSPF next-hop is resolved with the fully-connected direct next-hop to point to physical interface.</p> <p>CEF is used in the data plane with the FIB and adjancency table. An ARP cache is consulted (or query triggered) if the MAC address is not in the Adj table. </p> <p>FIB entries are only generated when there is a change in the RIB, which is then reflected in the FIB. </p> <p>For MPLS Forwarding, there are two additional tables, the LIB and LFIB.</p> <ul> <li>As reminder, BGP routes do not get unique labels. They utilize shared labels for each unique BGP next-hop.</li> <li>The LFIB table is used in data plane to forward incoming labeled packets.</li> </ul> <p></p> <p>The FIB is still the primary forwarding table. If there is a next-hop label present in the FIB, it will add a label to the packet before forwarding (ingress LSR functionality).</p> <p>The LFIB table will be used to forward labeled packets:</p> <ol> <li>If next-hop label exists in the LFIB, label will be replaced (swapped). This is core LSR functionality.</li> <li>If next-hop label does not exist (pop), then label will be removed, and packet will be forwarded as an IP packet via egress edge LSR functionality.</li> </ol>"},{"location":"MPLS%20LDP/#loop-detection-in-mpls","title":"Loop Detection in MPLS","text":"<p>Most routing loops are prevented by the IGP. MPLS follows IGP shortest paths, and these paths should be loop-free.</p> <p>MPLS labels do contain a TTL field is there is a loop (like, misconfigured static route). This TTL value is copied from the IP header, called <code>TTL Propagation</code>, which is enabled by default.      - On ingress, TTL copied from IP header into label header     - TTL decremented at each label hop     - On egress, TTL is copied from label to IP header</p> <p><code>TTL Propagation</code> can be disabled to \"hide\" the MPLS network from the end user. The labels get a TTL of 255, so there is still loop protection. </p> <p>Most commonly, this prevents the core routers from having to reply to traceroute packets to use low TTL's to trigger routers to send ICMP TTL expired for traceroute probes.</p> IOS XR<pre><code>RP0/CPU0:RTR# conf t\nRP0/CPU0:RTR(config)# mpls ip-ttl-propagate disable\n</code></pre> IOS XE<pre><code>router# conf t\nrouter(config)# no mpls ip propagate-ttl\n</code></pre> <p>If you disable it, ensure you disable it everywhere to prevent unexpected behavior.</p>"},{"location":"MPLS%20LDP/#link-failure-mpls-convergence-process","title":"Link Failure MPLS Convergence Process","text":"<p>LDP stores all labels in the LIB, even if they are not used, by default. If the IGP decides that a next-hop is no longer reachable, it will be removed from the FIB. This will remove the associated LIB and LFIB entries too.</p> <p>IGB determines another path to next-hop is available, which creates a new FIB entry. This new FIB entry already has a correspoding label in the LIBm so this is used to re-route the LSP.</p> <p>This results in MPLS convergence not being constrained by LDP convergence when there is a link failure. <code>Frame-mode MPLS</code> uses liberal label retention, which enables routers to store all labels, even those not used.</p>"},{"location":"MPLS%20LDP/#link-recovery-mpls-convergence-process","title":"Link Recovery MPLS Convergence Process","text":"<p>So in earlier example, the link that failed comes back up. The IGP determines the new path for the next-hop address, and it updates the FIB accordingly. </p> <p>A <code>pop</code> action is used in the LFIB over this new path until LDP establishes labels between the two routers. IP forwarding is used until a new next-hop label is available. HOWEVER, it is common for core LSR's to not have full tables (so IP lookups fail), so certain networks could be unreachable until LDP converges between routers.</p> <p>Cisco MPLS TE can be used to prevent long downtime when a link fails or when it is recovering.</p> IOS XE<pre><code>router# show ip cef $prefix detail\nrouter# show mpls forwarding-table $prefix\n</code></pre> <p>These can help identify next-hops and associated labels</p>"},{"location":"MPLS%20LDP/#mpls-implementation","title":"MPLS Implementation","text":"<p>You must have a functional IP network with addressing and routing before adding MPLS. </p>"},{"location":"MPLS%20LDP/#basic-configuration","title":"Basic configuration","text":"<p>IOS-XR:</p> <ul> <li>Enable LDP on an interface under MPLS LDP configuration mode</li> <li>CEF is mandatory, it does not need to be enabled</li> </ul> <p>IOS-XE:</p> <ul> <li>MPLS forwarding is enabled when you enable MPLS in interface config mode</li> <li>CEF is enabled by default on modern platforms, IOS/IOS-XE</li> </ul>"},{"location":"MPLS%20LDP/#config-tasks","title":"Config Tasks","text":"<ul> <li>By default, a router will generate and propagate labels for all networks in the RIB. Configure conditional label advertisement if only a subset of networks is required for label-switching, such as router loopback addresses.</li> </ul> IOS XR<pre><code>!\nmpls ldp\n  interface Gi0/0/0/1\n  router-id 10.1.10.1\n!\nipv4 access-list NO_LDP\n  deny tcp any any eq 646\n  permit any any\n!\ninterface Gi0/0/0/1\n  ipv4 access-group NO_LDP ingress\n!\n</code></pre> IOS XE<pre><code>interface Gi0/0\n  mpls ip\ninterface Gi0/1\n  ip access-group NO_LDP\n!\nmpls ldp router-id 10.2.1.1\n!\nip access-list extended NO_LDP\n  deny tcp any any eq 646\n  permit ip any any\n!\n</code></pre> <p>IP TTL Propagation is enabled by default.</p> <ul> <li>You can disable it, but by default, the disable command will also break traceroute for network operators. </li> </ul> <p>IOS/IOS-XE config: <pre><code>PE2(config)# no mpls ip propagate-ttl ?\n   forwarded  Propagate IP TTL for forwarded traffic \n   local      Propagate IP TTL for locally originated traffic \n</code></pre></p> <p>IOS-XR config: <pre><code>RP/0/RSP0/CPU0:PE1(config)# mpls ip-ttl-propagate disable  \n   forwarded  Disable IP TTL propagation for only forwarded MPLS   packets \n   local      Disable IP TTL propagation for only locally generated MPLS packets \n</code></pre></p>"},{"location":"MPLS%20LDP/#mtu-requirements","title":"MTU Requirements","text":"<p>Label switching increases the MTU requirements on an interface because of the additional label header.</p> <p>There are 3 different MTU values to keep track of:</p> <ol> <li>The interface MTU.<ul> <li>On IOS-XE, this is the layer 3 IP payload size</li> <li>On IOS-XR, this is the layer 2 MTU</li> </ul> </li> <li>The IP MTU used to determine whether a nonlabeled IP packet is forwarded and possibly fragmented. The IP MTU has no impact on labeled IP packets.</li> <li> <p>The MPLS MTU determines the max size of a labeled IP packets -- MPLS shim + IP payload size. By default, the MPLS MTU equals the interface MTU.</p> </li> <li> <p>You can increase MTU on interfaces where you run MPLS in the core (P routers) to prevent unnecessary fragmentation. This is called jumbo frames, baby giants, giants; sometimes it needs to be configured to support them.</p> </li> </ol> <p><code>mpls mtu 1512</code> to support an IP MTU of 1500 bytes. 1500 is default IP MTU excluding layer 2 MTU, like ethernet will 14 bytes for 1514 L2 MTU.</p>"},{"location":"MPLS%20LDP/#ldp-configuration","title":"LDP Configuration","text":"<p>Similiar to IGP, there is protocol tuning available for LDP.</p> <p>LDP Sessions Protection Enables you to configure LDP to automatically protect sessions with all or a given set of peers. LDP initiates backup targetted hellos for neighbors through alternative paths for which primary link adjacencies already exist.</p> <p>This provides faster LDP convergence when a link recovers following an outage. </p> <p>In LDP configuration mode on IOS-XR: <code>session protection [duration seconds | infinite] [for peer-acl]</code> </p> <p>In global config mode on IOS-XE: <code>mpls ldp session protection</code></p> <pre><code>     [R2]\n    /    \\\n[R1] --- [R3]\n</code></pre> <p>So R1 - R3 have primary session, and LDP session protection sends targetted hellos between R1 and R3 via R2. </p> <p>LDP Graceful Restart and NSR Configuration Allows for graceful failover between Route Processors to ensure High Availability. Graceful restart is a way to recover from signaling and control plane failures without impacting forwarding. </p> <pre><code>mpls ldp\n  graceful restart\n  nsr\n</code></pre> <p>On IOS-XE, it is <code>mpls ldp graceful-restart</code></p> <p><code>graceful-restart [reconnect-timeout seconds | forwarding-state-holdtime seconds]</code></p> <p>So when you enable MPLS LDP graceful restart, if there is a failure on a SSO- or NSF-enabled router, data plane is not interrupted while the LDP control plane is rebuild. </p> <p>The failed LDP neighbor is performing graceful restarted, the peer marks associated forwarding state info as stale. If the peer does not recover in time, the peer will remove the failed forwarding state.</p> <p>LDP IGP Synchronization Configuration</p> <p>A lack of sync between IGP and LDP can cause MPLS traffic drops. Like, an IGP advertising and using a link before LDP convergence has occured, OR, a link may continue to be used by the IGP but LDP session has gone down.</p> <p>LDP considers a link converged when at least one LDP session is operating on the link for which LDP has sent labels and received at least one label from its peer. LDP will notify the IGP to advertise links with regular metrics. When the link is active, yet LDP is not converged, the IGP advertises its maximum metric. </p> <pre><code>router ospf 1\n  mpls ldp sync\n!\nrouter isis 1\n  interface gi0/1\n    address-family ipv4 unicast\n      mpls ldp sync\n!\n</code></pre> <p>LDP Autoconfiguration</p> <p>Allows you to automatically configure LDP on all interfaces that are associated with an OSPF or IS-IS interface. You can also disable auto-configuration on a per-interface basis.</p> <p><code>mpls ldp autoconfig</code> under router process or under specific area configuration.</p> <p>Label Advertisement Control</p> <p>Outbound label filtering for scalability, performance, or security reasons.</p> IOS XR<pre><code># only allow labels from 10.7.1.1 to peers,\ninterface lo0\n  ip address 10.7.1.1/32\n  no shut\n!\nmpls ldp \n  label\n    advertise\n      disable\n      for PFX to to PEER\n!\nipv4 access-list PEER\n  10 permit ipv4 any any\nipc4 access-list PFX\n  10 permit ipv4 host 10.7.1.1 any\n</code></pre> IOS XE<pre><code>interface lo0\n  ip address 10.8.1.1/32\n  no shut\n!\n!\nno mpls ldp advertise-label\n!\nmpls label advertise-labels for 20 to 21\n!\n!\naccess-list 20 permit host 10.8.1.1\naccess-list 21 permit any\n!\n</code></pre> <p>Label Acceptance Control</p> <p>Inbound filtering, very similiar to advertisement control in terms of configuration. Use access-lists to specify allowed hosts to send labels to host.</p>"},{"location":"MPLS%20LDP/#mpls-monitoring-and-verification","title":"MPLS Monitoring and Verification","text":"<p>Here are some common <code>show</code> commands to take a closer look at MPLS, LDP.</p> <p><code>show mpls interfaces</code></p> <ul> <li>Shows interfaces that are configured for MPLS</li> </ul> <p><code>show mpls ldp discovery</code></p> <ul> <li>Displays LDP discovery information, like which ports are receiving and transmitting LDP packets</li> </ul> <p><code>show mpls ldp neighbor [detail]</code></p> <ul> <li>Shows info on all LDP neighbors. The state <code>Oper</code> indicates the session is up. Detail also provides addresses bound to this peer.</li> </ul> <p><code>show mpls ldp bindings [summary]</code></p> <ul> <li>This displays the LIB. It will show the prefix found in route table, along with local label and peers and their remote labels.</li> </ul> <p><code>show mpls forwarding</code></p> <ul> <li>This displays the LFIB. Local label, outgoing label, prefix, outgoing interface, next-hop, and amount of bytes switched. I omitted the large number of optional CLI suffixes.</li> </ul> <p><code>show cef [prefix [mask]] [hardware {egress | ingress} | detail] [location {node-id | all}]</code></p> <ul> <li>A lot of options here, sort of like <code>show mpls forwarding</code>. You can view additional details in the FIB, including local/remote labels.</li> </ul>"},{"location":"MPLS%20LDP/#mpls-troubleshooting","title":"MPLS Troubleshooting","text":"<p>Mostly the same as IP troubleshooting-- <code>ping</code>, <code>traceroute</code>, <code>show</code> commands with <code>debug</code> as last resort. </p> <p>Common issue with broken LSP is in the core where P routers are not running BGP. If core LSPs are broken, then P routers will not be able to forward IP packets because they do not have the full tables. If core LSPs are broken, the VPNs will also stop working because core routers do not know about the VPN labels even if they run BGP because the VPN labels can only be correctly processed by the originating egress PE routers.</p>"},{"location":"MPLS%20LDP/#classic-ip-ping-traceroute","title":"Classic IP Ping, Traceroute","text":"<ul> <li>Tests reachability through global routing table on P and PE routers.</li> <li>Test reachability of L3VPN prefixes in their VRF tables via label switching. Usable on the PE routers within the required VRF.</li> <li>Customers can use tools to test L3VPN end to end</li> </ul> <p>Some considerations with classic <code>ping</code>, <code>traceroute</code>:</p> <ul> <li>Broken LSPs may not be revealed with <code>ping</code>, <code>traceroute</code></li> <li>Broken LSPs may revert back to IP forwarding</li> <li>This can be fine, but when you're layering services, like TE, L2VPN, L3VPN services will break.</li> </ul>"},{"location":"MPLS%20LDP/#mpls-ping-mpls-traceroute","title":"MPLS Ping, MPLS Traceroute","text":"<p>To use these, enable <code>mpls oam</code> in your environment. An FEC must be selected to choose the associated LSP with these tools. FECs can be IP prefix in FIB, L2VPN, MPLS TE tunnel LSP.</p> <ul> <li>Encapsulates UDP requests directly into selected LSP.</li> <li>Additional MPLS config choices into cmds:<ul> <li>Exp field, TTL, reply mode, output interface</li> <li>Explicit Null label usage</li> <li>Not subject to TTL propagation disabling</li> </ul> </li> <li>More information in replies<ul> <li>Labels, interfaces, many other LSP diagnostics</li> </ul> </li> </ul> <p>MPLS Ping</p> <ul> <li>UDP port 3503, TTL 255</li> <li>MPLS echo request<ul> <li>Inside echo request is about the tested FEC as an TLV attribute</li> <li>These TLV's are basically the additional CLI options on <code>mpls ping</code> such as downstream router and interface, MTU, and multipath information from the router where the request is processed</li> </ul> </li> <li>MPLS echo reply</li> <li>Labeled packet with IP (UDP) payload</li> <li>source address: routable address sender</li> <li>destination address: any IP in 127/8 (default is 127.0.0.1)<ul> <li>Using the 127/8 address in the IP header destination address field will cause the packet to not be forwarded by any routers using the IP header, if the LSP is broken somewhere inside the MPLS domain.</li> </ul> </li> <li>dest port is 3503</li> </ul> <p><code>ping mpls ipv4 172.16.7.4 255.255.255.255</code></p> <p>The option of <code>dsmap</code> shows next-hop label in MPLS ping output.</p> <p>MPLS Traceroute</p> <p><code>traceroute mpls ipv4 172.16.7.4 255.255.255.255</code></p> <ul> <li>Same as IP traceroute, outputs labels at hop</li> <li><code>MRU</code> shows lowest MTU of the path (Max Receive Unit)</li> </ul>"},{"location":"MPLS%20LDP/#troubleshooting-and-common-mpls-issues","title":"Troubleshooting and common MPLS issues","text":"<p>LDP session does not start</p> <p><code>show mpls ldp discovery</code> does not display the expected LDP neighbors. MPLS forwarding on router does not work.</p> <ul> <li>MPLS may not be enabled or configured properly between peers, such as enabled on expected peer interface.</li> <li>If LDP neighbors are discovered but the session will not establish, validate reachability between LDP nodes.</li> </ul> <p>Label distribution issues</p> <p><code>show mpls ldp bindings</code> on adjacent LSR does not show labels from LDP node. Possible common issues could be faulty software issue, conditional label advertisement config issues (faulty ACLs).</p> <p>Use <code>show mpls ldp discovery</code> to identify adjacent LSR IP address to properly assign to ACL in the label advertisement configuration via <code>mpls ldp label advertise</code></p> <p>MPLS breaks after an interface fails</p> <p>Common if a physical interface is used for LDP identifier. Manual configure the LDP router ID, referencing a loopback interface reachable by the IGP. </p> <p>You can verify local LDP ID with <code>show mpls ldp neighbors</code></p> <p>Packet forwarding issues</p> <p>Customer reports large packets are dropped. This can happen if there are label MTU issues or if a device in the forwarding path does not support jumbo packets.</p> <p>A common fix is to modify the MPLS MTU size, taking into account one or more possible MPLS labels in the path. </p> <p><code>traceroute</code> is the best tool to verify MRU to identify MTU in the path. Then check hop-by-hop the MTU settings on L2 segments. </p>"},{"location":"MPLS%20LDP/#unified-mpls-implementation","title":"Unified MPLS Implementation","text":"<p>Also known as seemless MPLS. RFC 3107. BGP LU - Labeled Unicast. Updated and obseleted in RFC8277. </p> <p>Unified MPLS allows MPLS networks to scale more easily. It is all about scaling. Commonly, SP's do M&amp;A activities, so different core networks may run different IGPs, or they may have different administrative sub-domains. They may also just be very, very large with scaling and management challenges. </p> <p>Unified MPLS is defined by the addition of extra features with traditional MPLS. In order to deliver end to end services, an e2e LSP is needed. The goal of Unified MPLS is to keep MPLS servers, like MPLS VPN, L2VPN, L3VP, but introduce greater scalability. </p> <p>Unified MPLS addresses some of this by:</p> <ul> <li>Carrying next-hop labels in BGP (PE lookbacks)</li> <li>No need for pseudowire stitching</li> <li>No need for complex inter-AS MPLS VPN solutions</li> <li>Providers end to end LSPs with BGP</li> </ul>"},{"location":"MPLS%20LDP/#unified-mpls-label-stack","title":"Unified MPLS Label Stack","text":"<p>Bog standard MPLS usually has two labels carrying MPLS services:</p> <ol> <li>Top label is LDP label</li> <li>Bottom label is a service label learned via MP-BGP (such as L2 and L3 MPLS VPNs)</li> </ol> <p>Unified MPLS adds another label into the stack:</p> <ol> <li>Top label is LDP label</li> <li>Second label is BGP label for PE next-hop reachability (RFC 3107)</li> <li>Bottom label is VPN label</li> </ol> <p></p> <p>So looking at this, we can see:</p> <ul> <li>Bottom label 6 is assigned by final egress PE connecting a VPN site, which is advertised via MP-BPG.</li> <li>The second label (Edge next-hop label) is assigned on inter-domain routers (ASBRs or EBGP routers) and is also advertised by BGP. This label is responsible for the reachability of inter-domain PE routers.</li> <li>The top label (intra-domain next-hop label) is assigned by LDP and is responsible for the reachability of inter-domain PE routers in individual domain core routers. </li> </ul>"},{"location":"MPLS%20LDP/#unified-mpls-configuration","title":"Unified MPLS Configuration","text":"<p>In general, you want to use Unified MPLS on very large networks with scalability issues. In general, this is extending MPLS from the core beyond the aggregate networks to access layers. As said before, there may be different IGP processes or two different IGPs running in aggregate layer versus core.</p> IOS XR<pre><code>RP0/CPU0:RTR# conf t\nRP0/CPU0:RTR(config)# mpls ip-ttl-propagate disable\n</code></pre> IOS XE<pre><code>router# conf t\nrouter(config)# router bgp 64998\nrouter(config-bgp)# address-family ipv4 unicast\nrouter(config-bgp-af)# neighbor 203.0.113.41 update-source Lo0\nrouter(config-bgp-af)# neighbor 203.0.113.41 next-hop-self\nrouter(config-bgp-af)# neighbor 203.0.113.41 send-label\n</code></pre> <p>The proposed guidelines to configure are:</p> <ul> <li>Turn the routers that would otherwise break end to end LSPs into ABRs that are Route Reflectors</li> <li>Enable sending of labels for IPv4 prefixes</li> <li>Use next-hop-self neighbor command to ensure e2e LSPs</li> </ul> <p>There are a two options for configuring based on architeture.</p> <ol> <li>ABR (between aggregate and core) does not set next-hop-self for prefixes into aggregate network. Instead, ABR must redistribute loopback prefixes of ABRs from core IGP into the aggregate IGP. This may require changes over time, so it seems there is still a scalability issue?</li> <li>ABR sets next-hop-self for prefixes advertised (reflected by BGP) by the ABR into aggregation network. </li> </ol>"},{"location":"MPLS%20TE/","title":"MPLS TE","text":""},{"location":"MPLS%20TE/#te-labels-and-forwarding-concepts","title":"TE Labels and Forwarding Concepts","text":"<p>MPLS TE uses a different set of protocols, not LDP, to enable source-based selection of the entire LSP used for TE. </p> <p>A link-state IGP must be used to determine the shortest path, then the output is used with RSVP to establish the LSP.</p> <p>A process of establishing a Cisco MPLS TE tunnel and forwarding traffic into it has a few steps:</p> <ul> <li>Information distribution: resource attributes are configured locally, then they are distributed to the headend routers of traffic tunnels. The resource attributes are flooded throughout the network using extensions (TLV's) on existing IGPs OSPF and IS-IS. <ul> <li>The flood of resource info occurs when: (1) link-state changes, (2) resource of a link changes (due to admin intervention), (3) amount of bw crosses a preconfigured threshold</li> </ul> </li> <li>Path selection: uses Constrained Shortest Path First (CSPF) to get an explicit route consistenting of a sequence of label switching routers. CSPF ignores links explicitly excluded by resource class affinities of tunnel traffic or links with insufficient bw.</li> <li>Tunnel admission control: manages the situation when a router along a computed path has insufficient bandwidth to honor the resource that is requested in the RSVP PATH message</li> <li>Forwarding the traffic into tunnel: traffic be forwarded a few different ways-- static routes, policy routing from global routing table, autoroute</li> <li>Path maintenance: There are two operations here-- path reoptimization and restoration</li> </ul>"},{"location":"MPLS%20TE/#resource-reservation-protocol-rsvp-in-path-setup","title":"Resource Reservation Protocol (RSVP) in Path Setup","text":"<p>A signalling protocol is used to confirm the path, to check and apply bw reservations, and to exchange MPLS labels to build LSP's.</p> <p>RSVP sets up the TE LSP with:</p> <ol> <li>PATH message (from head to tail) carrying LABEL_REQUEST</li> <li>RESV message (from tail to head) carrying the LABEL</li> </ol> <p>The result is a path with IP addresses of next-hop IP addresses along the path. </p> <p>However, this path is only known to the headend router. The intermediate routers do not make their own CSPF calculations; they merely abide by the path that is provided to them by the headend router. </p>"},{"location":"MPLS%20TE/#path-setup-admission-control-wrsvp","title":"Path Setup, Admission Control w/RSVP","text":"<p>The RSVP PATH message contains the explicit route calculated by CSPF on headend route. Each intermediate router performs admission control after receiving the PATH message. </p> <p>Tailend router receives PATH msg, then sends RESV msg back towards headend router. Each intermediate router along the path reserves bw and allocates labels for tunnel traffic. </p> <p>RSVP messages also provide support for LSP teardown and error signaling.</p> <p><code>RSVP Error</code> for the unavailability of the requested resources. An intermediate router may send <code>PATHERR</code> during admission control if it cannot accomodate resources requested in PATH msg from headend to tailend router. An intermediate router may also send <code>RESVERR</code> in response to lack of resources to tailend router in response to a RESV msg.</p> <p><code>RSVP Tear</code> has two types-- PATH tear and RESERVATION tear messages. </p> <ul> <li>The process of clearing a PATH or RESERVATION state on a router using tear messages enables the reuse of resources on the router for other requests. The PATH tear messages are usually generated in inter-area LSP creation where the inter-area LSP is not configured to be fast reroutable, and if a link failure occurs within an area, the LSR to which the failed link is directly attached will generate an RSVP PATH error and an RESV tear message to the headend. The headend will then generate an RSVP PATH tear message. </li> </ul> <p>On intermediate routers, trunk admission control is used to ensure each device has sufficient bw to support resources requested in PATH msg. There are priority levels 0-7. If there is enough bw, the reservation is accepted, otherwise the path setup fails. Then when the RSVP RESV msg comes back, the router reserves the bw for the LSP.</p> <p>As part of admission control, the router does local accounting to track resources and may trigger IS-IS or OSPF updates when available resources cross a configured threshold.</p>"},{"location":"MPLS%20TE/#forwarding-traffic-to-a-tunnel","title":"Forwarding Traffic to a Tunnel","text":"<p>The LSP or traffic tunnel will not appear in the IP routing table, since it is not known to routing processes. </p> <p>IP traffic can be mapped onto a traffic tunnel in four ways:</p> <ul> <li>Use static routes that point to the tunnel interfaces.</li> <li>Using policy-based routing (PBR), set the next hop for the destination to the tunnel interface.</li> <li>Use the autoroute feature, an SPF enhancement that includes the tunnel interface. The result of the autoroute feature is that the tunnel is seen at the headend (and only there) as a connected interface. The metric of the tunnel is set to the normal IGP metric from the tunnel headend to the tunnel endpoint (over the least-cost path, regardless of whether the tunnel is actually using the least-cost path). With the autoroute feature, the traffic-engineered tunnel appears in the IP routing table, but this appearance is restricted to the tunnel headend only.<ul> <li>Enables all prefixes topologically \"behind\" the tailend router to be reachable via the autoroute tunnel on headend.</li> </ul> </li> </ul> <p>Autoroute with Forwarding Adjacency</p> <ul> <li>Allows the tunnel to be announced via OSPF or IS-IS as a p2p link to other routers. The tunnel MUST be setup bidirectionally, since it is possible with MPLS RSVP for the LSP to take different unidirectional paths.</li> <li>TE tunnel interfaces are advertised like any other link into the IGP. </li> </ul>"},{"location":"MPLS%20TE/#mpls-te-attributes","title":"MPLS TE Attributes","text":"<p>Traditional link-state IGP considers nodes and links to calculate shortest path. BUT, the CSPF algorithm considers additional information such as available resources or constraints. Then, the IGP is responsible for distributing available resource and constraint info. </p> <p>Links have their own attributes, then tunnels will have their own set of attributes. Tunnel attributes seemingly must fit within the attributes defined per link end-to-end.</p> <p>Link-resource attributes:</p> <ol> <li>Maximum bw</li> <li>Maximum reservable bw</li> <li>Link-resource class</li> <li>Constraint-based specific link metric</li> </ol> <p>Tunnel attributes:</p> <ol> <li>traffic parameter</li> <li>general path selection and management</li> <li>tunnel resource </li> <li>adaptability</li> <li>priority</li> <li>pre-emption</li> <li>resilience</li> </ol>"},{"location":"MPLS%20TE/#link-resource-attributes","title":"Link-resource attributes","text":"<p>There are 3 Bandwidth link-resource attributes:</p> <ul> <li><code>Maximum bandwidth</code></li> <li><code>Maximum reservable bandwidth</code></li> <li><code>Unreserved bandwidth</code></li> </ul> <p>There could be non-MPLS traffic on the links, so leaving room could be useful. The attribute is a measure of allocation, not the actual utilization.</p> <p>Also, there are priority levels for traffic tunnels, this availability information needs to be configured for each priority level on the link. The bw at the upper priority level is typically higher than at lower levels (0-7 levels). Because of oversubscription, the total amount of bandwidth can exceed the actual bandwidth of the link.</p> <p>The <code>Link-resource class</code> attribute is a 32 byte value that is the traffic tunnel resource class affinity attribute, and allows inclusion or exclusion of the link into the path of the tunnel.</p> <p><code>Administrative weight</code> is a constraint-based metric that is not related to IGP cost/metric. This will default to IGP link cost if not defined. </p>"},{"location":"MPLS%20TE/#te-tunnel-attributes","title":"TE Tunnel Attributes","text":"<p><code>traffic parameter</code> (bandwidth) attributes specifies the amount of bw required by the TE tunnel. There could be other traffic characteristics, such as peak rates, avg rates, permissible burst rate, etc. </p> <ul> <li>These characteristics are useful for resource allocation. A path is not considered for a Cisco MPLS TE tunnel if it does not have the bandwidth that is required.</li> </ul> <p><code>path selection and management</code> attributes (path selection policy) specifies the way in which the headend routers should select explicit paths for traffic tunnels.</p> <p><code>tunnel resource class affinity</code> attribute allows for an operator to apply path-selection policies by administratively including or excluding links.</p> <ul> <li>Each link may include <code>link-resource class</code> attribute, then a tunnel <code>resource class affinity</code> could explicitly include or exclude links when doing path-selection. Basically, this sounds like manual traffic steering to ensure TE doesn't go off the rails and pick a really bad path or something similiar.</li> </ul> <p><code>Adaptivity</code> attribute indicates whether the TE tunnel is subject to re-optimization or re-routed through different paths by the underlying IGP based on changing resource availability.</p> <p><code>Priority</code> attribute defines the order in which path selection during establishment and under faulty scenarios. This is very important to define if there is preemption during RSVP process to establish TE tunnels.</p> <p><code>Preemption</code> attribute determines whether another traffic tunnel can pre-empt a specific TE tunnel. </p> <p>There are two types of priorities to define for TE tunnels:</p> <ol> <li>Setup priority (<code>priority</code>) defines relative important of tunnels and determines the order in which path selection is done for traffic tunnels at connection establishment and during rerouting because of faulty conditions.</li> <li>Holding priority (<code>preemption</code>) defines \"pre-emptive\" rights of competing tunnels and specifies priority of a router to hold a tunnel resource. Useful when trying to differentiate between services and following faults under re-route or contention events. </li> </ol> <p><code>resilience</code> attribute defines the behavior of a TE tunnel in faulty conditions or if the tunnel becomes noncompliant with tunnel attributes (like, required bw).</p> <p>Some examples of what the <code>resilience</code> attribute may do</p> <ul> <li>Do not reroute the TE tunnel<ul> <li>For example, a survivability scheme may already be in place, provisioned through an alternate mechanism, which guarantees service continuity under failure scenarios without the need to reroute tunnels.</li> </ul> </li> <li>Reroute through a feasible path with enough resources. If none exists, then do not reroute.</li> <li>Reroute through any available path regardless of resource constraints.</li> </ul>"},{"location":"MPLS%20TE/#implementing-te-policies-with-affinity-bits","title":"Implementing TE policies with Affinity Bits","text":"<p>Each tunnel can have a 32-bit resource class <code>affinity</code> string, which has a mask to exlcude the respective link resource class bits from being checked. </p> <p>Resource class affinity attributes associated with a TE tunnel can be used to specify the class of resources (see Section 6 of rfc2702) which are to be explicitly included or excluded from the path of the TE tunnel. These are policy attributes which can be used to impose additional constraints on the path traversed by a given TE tunnel.</p> <p>The link is characterized by following: - The link resource class (default value is 0). - The resource class is propagated using a link-state IGP</p> <p>The tunnel is characterized by the following: - Tunnel resource class affinity (default value is 0) - Tunnel resource class affinity mask     - Mask meaning: 0 = do not care, 1 = care (link's resource class bit must match the tunnel bit)     - Default value of the tunnel mask is 0x0000FFFF</p> <p>So for example, tunnel affinity = <code>Bits: 0000 Mask: 0011</code>. If there is a link resource class with <code>0010</code>, then the tunnel cannot traverse that link in the path. </p> <p>Resource class affinity attributes are very useful and powerful constructs because they can be used to implement a variety of policies. For example, they can be used to contain certain traffic trunks within specific topological regions of the network.</p>"},{"location":"MPLS%20TE/#mpls-te-path-setup-computation-and-optimization","title":"MPLS TE Path Setup, Computation, and Optimization","text":"<p>Once a headend router has the necessary info (topology, link costs, resources and constraints), then it can use this to calculate best paths for configured TE tunnels.</p> <p>IGP's must distribute all link characterists to other routers in the MPLS TE domain.</p> <ul> <li>Resource flooding is triggered whenever there is significant change that could affect other routers when they perform CSPF.</li> <li>Resource flooding triggers are:<ul> <li>link state change</li> <li>config changes: cost, resource class, bw</li> <li>amount of available bw crosses a preconfigured thershold</li> <li>periodic (timer-based)... a node checks attributes, if changes, it floods updates</li> <li>LSP setup failure when processing RSVP RESV</li> </ul> </li> </ul> <p>OSPF uses opaque LSAs and IS-IS uses new TLV's</p> <p>Another important factor in LSP computation is the available bandwidth on the link over which the traffic tunnel will pass. This bandwidth is configured per priority level (8 levels, 0 being the highest, 7 the lowest) and communicated in respective IGP link-state updates, again per priority.</p> <p>When a certain amount of the bandwidth is reserved at a certain priority level, this amount is subtracted from the available bandwidth at that level and at all levels below. The bandwidth at upper levels remains unchanged.</p> <p>For stability, significant rapid changes in available link resources should not trigger the updates immediately. There are timers for this.</p> <p>The drawback could be that a headend router seeing a link as available for a LSP and includes the link in path computation, even if the link is down or does not have enough resources. When the RSVP PATH message is sent, the node with the cannot establish the link and immediately floods an update.</p>"},{"location":"MPLS%20TE/#constraint-based-path-computation","title":"Constraint-based path computation","text":"<p>So, now the headend router will have a full view of the topology and network resources which is flooded throughout the network via the IGP.</p> <p>An explicit route expressed as a sequence of interface IP addresses (for numbered links) or TE router ID's (for unnumbered links) in the path from headend tunnel endpoints.</p> <p>Two methods for establishing tunnel traffic: (1) static, (2) dynamic path setup</p> <p>RSVP is used for LSP signalling to tailend router to establish the final path.</p> <p>LSP computation is limited by several factors (constraint-based):</p> <ol> <li>Endpoints are in the same IS-IS or OSPF area due to link-state topology limitations</li> <li>The links that are explicitly excluded via the link resource class bit string, or that cannot provide the required bandwidth, are pruned from the computation.</li> </ol>"},{"location":"MPLS%20TE/#path-selection-wconstraint-based-computation","title":"Path Selection w/Constraint-Based computation","text":"<p>Prior to path selection, link evaluation will automatically exclude links that are excluded via resource class affinities. </p> <p>Establishment of a tunnel does not trigger any LSA announcements or a new SPF calculation (unless the forwarding adjacency feature is enabled).</p> <p>The word tunnel is a little misleading, in that it is more like a visualization of a concept. </p> <p>With the autoroute feature, the TE tunnel on the headend router has the following characteristics:</p> <ul> <li>Appears in the routing table</li> <li>Has an associated IP metric (cost equal to the best IGP metric to the tunnel endpoint)</li> <li>Is also used to forward the traffic for destinations behind the tailend tunnel endpoint</li> </ul> <p>Path-selection for Constrained-based Routing(CBR):</p> <ol> <li>It's own metric first, which is <code>administrative weight</code></li> <li>If tie, then select the path with highest minimum bandwidth</li> <li>If tie, select path with the smallest hop count</li> <li>If above fails, then pick a random path.</li> </ol> <p>RSVP in the Path Setup</p> <p>After an explicit route is selected via CBR, the explicit route is used with RSVP to assign labels and reserve bw on each link. Additionally, RSVP transports traffic parameters and maintains the control and policy over the path. The maintenance is done by periodic refresh messages that are sent along the path to maintain the state.</p> <p>RSVP then signals routers in the path from headend to tailend to reserve resources to establish the LSP path and allocate labels. If good, a unidirectional TE tunnel is established, as only seen on headend router.</p>"},{"location":"MPLS%20TE/#hop-by-hop-path-setup-with-rsvp","title":"Hop-by-Hop Path Setup with RSVP","text":"<p>[R1]Eth1 - Eth2[R2]Eth1 - Eth2[R3]</p> <p>R1 headend sends RSVP PATH to R3 tailend.</p> <p>There are RSVP objects in the PATH message:</p> <ul> <li>Session(tailend, headend) like <code>(R3-lo0, R1-Lo0)</code></li> <li>Explicit route object (ERO), which is a explicit list of next hops chosen by CBR. <ul> <li>Like <code>(R2-Eth2, R3-Eth2)</code></li> </ul> </li> <li>PHOP (Previous Hop), like (<code>R1-Eth1</code>)</li> <li>Other fields...</li> </ul> <p>As the next-hop router (R2) receives the RSVP PATH message, the router checks the ERO and looks into the L bit regarding the next-hop information. If this bit is set and the next hop is not on a directly connected network, the node performs a CBR calculation (path calculation, or PCALC) using its TE database and specifies this loose next hop as the destination.</p> <p>In this way, the ERO is augmented by the new results and forms a hop-by-hop path up to the next loose node specification.</p> <p>Intermediate routers along the path (indicated in the ERO) perform the traffic tunnel admission control by inspecting the contents of the session attribute object. If the node cannot meet the requirements, it generates a PATH_ERR message. If the requirements are met, the node is saved in the Record Route Object of the RSVP PATH message.</p> <p>At the tailend router, upon receiving the PATH message, the <code>label_request</code> triggers path label allocation. The label is placed in the corresponding label object of the RSVP RESV message that is generated. The RSVP message is sent back to the headend following the reverse path that is recorded in the RRO, and is stored at each hop in its path state block.</p> <p>Each hop allocates a label, which is stored and replaced in the <code>Label</code> field of the RSVP RESV message. Also, as the RESV packet traverses the reverse path, the <code>NHOP</code> field is moved into the <code>Record Route</code> (RRO) field of the RESV packet. Upon arrival back at the headend, the RRO in the RESV packet should match the Explicit Route in the RSVP Path message initially sent.</p>"},{"location":"MPLS%20TE/#te-tunnel-and-link-admission-control","title":"TE tunnel and link admission control","text":"<p>When the RSVP PATH message is sent from headend router to tailend router, each hop on the way determines if the available resources specified in the <code>Session</code> attribute object are available. </p> <p>If there is not enough bandwidth, the link-level (per-hop) call admission control (LCAC) module informs RSVP about the lack of resources, and RSVP generates an <code>RSVP PATH_ERR</code> message with the code Requested bandwidth unavailable. Additionally, the flooding of the node resource information (by the respective link-state IGP) can be triggered.</p> <p>If there is enough bw, then the bw is reserved and put into the waiting pool for the RESV message to come back around. If the resource threshold is reached, then the IGP triggers the flooding of resource info. </p> <p>During admission control, priorities are checked. If there is a prempt action to be taken, then lower priority sessions are booted with reservation triggers a <code>RESV_ERR</code> or a <code>PATH_ERR</code> message or both with the code Policy control failure.</p>"},{"location":"MPLS%20TE/#path-rerouting-and-reoptimization","title":"Path Rerouting and Reoptimization","text":"<p><code>reoptimization</code> is done on a periodic basis if used. At certain intervals, a check for most optimal paths for LSPs tunnels is done, then if the current path is not the most optimal, then tunnel rerouting is initiated.      - Default is 1 hour for <code>reoptimization</code></p> <p>After the new LSP is successfully established, the traffic is rerouted to the new path and the reserved resources of the previous path are released. The release is done by the tail-end router, which initiates an <code>RSVP PATH_TEAR</code> message.</p> <p>When a link failure occurs, a new path calc is done, then a new LSP is created. This can be detected one of two ways:</p> <ol> <li>IGP sends new link-state packet with about path changes</li> <li>RSVP alarms the failure via <code>RSVP PATH_TEAR</code> to the headend</li> </ol> <p>But overall, both indicate that the LSP is no longer available, and likely reasons could be:</p> <ul> <li>link or router in path is down</li> <li>LSP is preempted by another LSP</li> </ul> <p>RSVP session is torn down, and there is a new path calculation. If a new path is found, a new LSP is signaled via RSVP, and the headend router updates adjacency table is updated to this new tunnel, then CEF table updated for all routes using this tunnel adjacency. </p> <p>NOTE, during a reroute event where the old LSP is not available, traffic intended for the tunnel will be using the old LSP, which will blackhole the traffic.</p> <p>The process of freeing resources in the established LSP paths is called MPLS-TE preemption. In order to reduce traffic interruption, <code>soft pre-emption</code> feature is introduced to the RSVP-TE protocol to minimize traffic disrupted on preempted LSP.</p> <p>The <code>soft preemption</code> feature tries to pre-empt established LSP in a graceful manner to avoid or minimize traffic loss. In some cases, the link can be oversubscribed for a longer period of time.</p>"},{"location":"MPLS%20TE/#assigning-traffic-to-te-tunnels","title":"Assigning traffic to TE tunnels","text":"<p>Aka, routing traffic into tunnels</p> <p>From an IP perspective, the LSP is just a tunnel. </p> <p>You can use static routes pointing to the tunnel interface. Like not scalable or nice for troubleshooting.</p> <p>The autoroute feature enables all the prefixes that are topologically behind the Cisco MPLS TE tunnel endpoint (tail end) to be reachable via the tunnel itself (unlike with static routing, where only statically configured destinations are reachable via the tunnel). </p> <p>The cost of the tunnel is equal to the best IGP metric to the tunnel endpoint, regardless of the LSP. The tunnel metric is tunable using either relative or absolute metrics.</p> <p>Because <code>autoroute</code> will use IGP metrics, you should ensure the native IP routing to prefixes you want to reach via the tunnel does not appear as \"better\". You can use <code>relative metric</code> set to <code>-2</code> to ensure the tunnel autoroute is always 2 less metric than native shortest-path. </p> <p>Forwarding Adjacency</p> <p>The <code>forwarding adjacency</code> allows an operator to handle TE tunnel like another link on the IGP, based on SPF. </p> <p>By using forwarding adjacency, you can achieve the following goals: - Better load balancing when you are creating POP-to-POP tunnels (ECMP) - Use of tunnels from any upstream node, independent of the inner topology of the network</p> <p>There are some restrictions:</p> <ul> <li>Increases the size of LSDB in the IGP.</li> <li>The link is advertised in the IGP network as a type, length, value (TLV) 22 object without any TE sub-TLV.</li> <li>TE tunnels must have bidirectional LSP </li> </ul> <p>However, MPLS TE with forwarding adjacency can advertise links between POP's to be equal-cost irrespective of the underlying IGP cost. This ensure POP-to-POP traffic is better load balanced.</p> <p>MPLS TE IPv6 Autoroute advertises IPv6 routes over MPLS/TE IPv4 tunnels. The tunnel must be IPv6-enabled so it can carry IPv6 traffic. In order to advertise the tunnel, IPv6 forwarding adjacency or IPv6 autoroute announce must be configured on the tunnel.</p> <p>Usage and restrictions of this... - IPv6 autoroute feature is used for IPv4 MPLS TE tunnels using IPv6 routing - The IPv6 traffic will not consider the UELB (Unequal Load Balancing) configuration. However, equal load balancing works for IPv6. - IPv6 traffic will not consider policy-based tunnel selection, although it can be used for IPv4 traffic - IPv6 autoroute announce and IPv6 forwarding adjacency are not supported by MPLS <code>auto tunnels</code>.</p>"},{"location":"MPLS%20TE/#configure-mpls-te","title":"Configure MPLS TE","text":"<p>To configure MPLS TE tunnels, MPLS should already be enabled on the core network.</p> <p>The high level overview to conf MPLS TE is:</p> <ul> <li>Enable MPLS TE in the core</li> <li>Configure RSVP in the core</li> <li>Enable MPLS TE support in the core IGP OSPF or IS-IS</li> <li>Configure MPLS TE tunnels</li> <li>Configure routing into the the tunnels</li> </ul>"},{"location":"MPLS%20TE/#enabling-mpls-te","title":"Enabling MPLS TE","text":"IOS XE<pre><code>router# conf t\nrouter(config)# mpls traffic-eng\nRouter(config-mpls-te)# interface GigE 0/3\nRouter(config-mpls-te)# interface GigE 0/4\n</code></pre> IOS XR<pre><code>RP0/CPU0:RTR# conf t\nRP0/CPU0:RTR(config)# mpls traffic-eng tunnels\nRP0/CPU0:RTR(config)# interface GigE 0/0/0/4 \nRP0/CPU0:RTR(config-if)# mpls traffic-eng tunnels\n</code></pre>"},{"location":"MPLS%20TE/#rsvp-configuration","title":"RSVP Configuration","text":"IOS XR<pre><code>rsvp\n!\n  interface Gi0/0/0/4\n    bandwidth 1000\n  interface Gi0/0/0/1\n    bandwidth 10000 1000\n!\n</code></pre> <p><code>bandwidth</code> <code>total-bandwidth max-flow</code> <code>sub-pool sub-pool-bw (optional)</code></p> IOS XE<pre><code>interface GigE 0/3\n  ip rsvp bandwidth 10000 1000\n!\n</code></pre>"},{"location":"MPLS%20TE/#ospf-configuration","title":"OSPF Configuration","text":"IOS XR<pre><code>router ospf 1\n  mpls traffic-eng router-id Loopback0\n  area 0\n    mpls traffic-eng\n  !\n!\n</code></pre> IOS XE<pre><code>router ospf 1\n  mpls traffic-eng area 0\n  mpls traffic-eng router-id Loopback0\n</code></pre>"},{"location":"MPLS%20TE/#is-is-configuration","title":"IS-IS Configuration","text":"IOS XR<pre><code>router isis 1\n  net 47.0001.0000.0000.0002.00\n  address-family ipv4 unicast\n    metric-style wide\n    mpls traffic-eng level-1-2\n    mpls traffic-eng router-id Loopback0\n  !\n!\n</code></pre> IOS XE<pre><code>router isis 1\n  mpls traffic-eng level-1-2\n  mpls traffic-eng router-id Loopback0\n  metric-style-wide\n</code></pre>"},{"location":"MPLS%20TE/#mpls-te-tunnel-configuration","title":"MPLS TE Tunnel Configuration","text":"<p>After enabling OSPF or IS-IS to distribute MPLS TE info, and after enabling MPLS TE functionality on desired interfaces + RSVP config, you can configure MPLS TE tunnel configs. </p> <p>[PE1] - [P1] - [P2] - [PE2]</p> <p>PE1 router IOS XR<pre><code>interface Tunnel-te 1\n  ipv4 unnumbered Loopback0\n  signalled-bandwidth 1000\n  destination 192.0.10.1 # this assigns an dest IP on the tunnel\n  path-option 1 dynamic\n  autoroute announce # this is autoroute\n!\nrouter static address-family ipv4\n  unicast 192.0.100.0/24 tunnel-te 1 # this would be a static route option\n</code></pre></p> <p>PE2 router IOS XE<pre><code>interface Tunnel11\n  ipv4 unnumbered Loopback0\n  tunnel mode mpls traffic-eng\n  tunnel mpls traffic-eng path-option 1\n  tunnel mpls traffic-eng bandwidth 1000\n  destination 192.0.2.1 # this assigns an dest IP on the tunnel\n  tunnel mpls traffic-eng autoroute # autoroute \n!\nip route 192.0.200.0 255.255.255.0 Tunnel11 # this would be a static route\n!\n</code></pre></p> <p>To configure an Explicit Cisco MPLS TE Tunnel (not dynamic path), do the following:</p> IOS XR<pre><code>!\nmpls traffic-eng\n  reoptimize 300 # every 5 mins check\n  interface Gi0/0\n    admin-weight 55\n!\ninterface GigabitEthernet 0/0\n description RED link to server farm, avoid having tunnels route through\n mpls traffic-eng attribute-flags 0x00000001\n!\ninterface GigabitEthernet 0/1\n description BLUE link\n mpls traffic-eng attribute-flags 0x00000001\n!\ninterface Tunnel-te 1\n  description BLUE tunnel\n  ipv4 unnumbered Loopback0\n  signalled-bandwidth 2500\n  destination 192.0.3.1\n  priority 1 1\n  path-option 1 explicit name Core2-3\n  path-option 2 dynamic # if the static first path fails, a dynamic path LSP is found\n  affinity 0x00000002 mask 0x00000002\n  autoroute annouce # autoroute with forward adjacency\n!\nexplicit-path name Core2-3\n  index 1 next-address ipv4 unicast x.x.x.x\n  index 2 next-address ipv4 unicast y.y.y.y\n  index 3 next-address ipv4 unicast z.z.z.z\n!\n</code></pre>"},{"location":"MPLS%20TE/#mpls-te-verification-and-troubleshooting","title":"MPLS TE Verification and Troubleshooting","text":"<p>These are IOS-XR...</p> <p><code>show mpls traffic-eng tunnel</code> to look at the status of the LSP tunnels and RSVP processes along with each tunnel and the hop list of current LSP.</p> <p><code>show mpls traffic-eng topology</code> will show neighbors on which interface, then different priorities and how much BW is allocated per priority + also the IGP and area.</p> <p>The first thing to do when verifying MPLS TE would be to verify RSVP</p> <p><code>show rsvp session</code> and <code>show rsvp interface</code></p> <p>Then check the tunnel statuses etc.</p> <p>To look at the routing table for MPLS TE routes, there is no unique table. You'll need to pipe to filter down.</p> <p><code>show ip route | include tunnel-te</code> if autoroute is enabled.</p>"},{"location":"MPLS%20TE/#mpls-te-redundancy-mechanisms","title":"MPLS TE Redundancy Mechanisms","text":"<p>Cisco MPLS TE tunnels can also be protected by backup tunnels to ensure speedy convergence in case of node or link failures. We can build parallel end-to-end tunnels, have backup tunnels on core nodes to protect individual links or neighboring nodes in case of failures.</p> <p>Overall, the idea is that there are presignaled LSP already available if first tunnel fails. As soon as first tunnel fails, traffic is moved into second tunnel. Then back once first tunnel is re-available.</p> IOS XR<pre><code># at Dallas POP, tunnels to ATL\n!\ninterface tunnel-te 1\n  description Static tunnel to Atl\n  ipv4 unnumbered Lo0\n  destination 192.0.100.1\n  signalled-bandwidth 250\n  priority 1 1\n  path-option 1 explicit name Core3-2\n!\nexplicit-path name Core3-2\n  index 1 next-address ipv4 unicast P1\n  index 1 next-address ipv4 unicast P2\n  index 1 next-address ipv4 unicast PE-ATL\n!\ninterface tunnel-te 2\n  description Dynamic backup tunnel to Atl\n  destination 192.0.100.1\n  signalled-bandwidth 125\n  priority 2 2\n  ipv4 unnumbered Lo0\n  path-option 1 dynamic\n!\nrouter static address family ipv4\n  unicast 192.0.200.0/20 tunnel-te 1 10\n  unicast 192.0.200.0/20 tunnel-te 2 11\n!\n</code></pre> <p>There is a drawback with backup tunnels, they double reserve bandwidth via RSVP over the entire path.</p>"},{"location":"MPLS%20TE/#fast-reroute-frr","title":"Fast reroute (FRR)","text":"<p>Provides link protection to LSPs enabling the traffic carried by LSPs that encounter a failed link to be rerouted around the failure.</p> <p>There is <code>link protection</code> and <code>node protection</code>.</p> <p>The reroute decision is controlled locally by the router connected to the failed link. The headend router on the tunnel is notified of the link failure through IGP or through RSVP. When it is notified of a link failure, the headend router attempts to establish a new LSP that bypasses the failure. This provides a path to reestablish links that fail, providing protection to data transfer. The path of the backup tunnel can be an IP explicit path, a dynamically calculated path, or a semi-dynamic path. </p> <p>These tunnels are referred to as next-hop (NHOP) backup tunnels because they terminate at the LSP\u2019s next hop beyond the point of failure. </p> <p>When the protected link or protected router go down, IGP re-converges. RSVP sends a message with session attribute flag 0x01=ON. (This means, Do not break the tunnel; you may continue to forward packets during the reoptimization.)</p> <p>~50ms re-route protection.</p> <p>Headend is notified via RSVP PATH_ERR and by IGP, there is a special flag in RSVP message that indicates the path must not be destroyed but continue an re-establish along new route.</p> IOS XR on Dallas POP PE1<pre><code>!\ninterface tunnel-te 1\n  destination 192.0.100.1 # this is to ATL POP PE1\n  fast-reroute\n  signalled-bandwidth 125\n  priority 1 1\n  ipv4 unnumbered Lo0\n  path-option 1 dynamic\n  autoroute annouce\n  autoroute metric absolute 1\n!\n</code></pre> <p>We manually craft the backup tunnel on intermediate core routers used by headend routers and FRR.</p> IOS XR on Dallas P1<pre><code>!\ninterface tunnel-te 1001\n  destination 192.0.80.1 # this is to P1 in ATL\n  signalled-bandwidth 1000 # needs higher bw to support multiple tunnels\n  priority 7 7\n  ipv4 unnumbered Lo0\n  path-option 1 explicit name Backup-path\n!\nexplicit-path name Backup-path\n  index 1 next-address ipv4 unicast ATL-P2\n  index 2 next-address ipv4 unicast ATL-PE2\n!\nmpls traffic-eng \n  interface Gi0/0/0/1 # interface to P2\n    backup-path tunnel-te 1000\n</code></pre>"},{"location":"MPLS%20TE/#mpls-te-autotunnel-backup","title":"MPLS TE Autotunnel Backup","text":"<p>Configuring backup static tunnels for all core links does not scale well.</p> <p>Autotunnel backup characteristics:</p> <ul> <li>Automates configuration of backup FRR tunnels for link and node protection.</li> <li>Configured globally and applies to all interfaces enabled for Cisco MPLS TE.</li> <li>Provides FRR for all tunnel LSPs traversing the protected interface.</li> <li>Autotunnel backup feature creates two types of link protection tunnels: <ul> <li>Link-protection tunnels (NHOP protection)</li> <li>Node-protection tunnels (next-next hop protection)</li> </ul> </li> </ul> IOS XR from Cisco.com<pre><code>Router# configure\nRouter(config)# mpls traffic-eng \nRouter(config-mpls-te)# interface HundredGigabitEthernet 0/0/0/3\nRouter(config-mpls-te-if)# auto-tunnel backup\nRouter(config-mpls-te-if-auto-backup)# attribute-set ab\nRouter(config-mpls-te)# auto-tunnel backup timers removal unused 20\nRouter(config-mpls-te)# auto-tunnel backup tunnel-id min 6000 max 6500\nRouter(config-mpls-te)# commit\n</code></pre> <p>IOS-XR: <code>show mpls traffic-eng auto-tunnel backup summary</code> IOS-XE: <code>show mpls traffic-eng auto-tunnel backup</code></p>"},{"location":"MPLS%20TE/#mpls-te-autotunnel-mesh","title":"MPLS TE Autotunnel Mesh","text":"<p>Manual configuration of tunnels could suck. This feature lets you setup a full mesh of TE tunnels automatically.</p> <p>Autotunnel mesh characteristics:</p> <ul> <li>Simplify wide-scale deployment of Cisco MPLS TE tunnels.</li> <li>All routers configured with the same mesh group ID will form a full mesh of tunnels.</li> <li>Prefix list can define mesh-group member addresses.</li> <li>Attribute sets enable reusable configuration.</li> </ul> <p>Auto-Tunnel mesh configuration minimizes the initial configuration of the network. You can configure tunnel properties template and mesh-groups or destination-lists on TE LSRs that further creates full mesh of TE tunnels between those LSRs. It eliminates the need to reconfigure each existing TE LSR in order to establish a full mesh of TE tunnels whenever a new TE LSR is added in the network. </p> IOS XR from Cisco.com<pre><code>Router# configure\nRouter(config)# mpls traffic-eng\nRouter(config-mpls-te)# auto-tunnel mesh\nRouter(config-mpls-te-auto-mesh)# tunnel-id min 1000 max 2000\nRouter(config-mpls-te-auto-mesh)# group 10\nRouter(config-mpls-te-auto-mesh-group)# attribute-set 10\nRouter(config-mpls-te-auto-mesh-group)# destination-list dl-65\nRouter(config-mpls-te)# attribute-set auto-mesh 10\nRouter(config-mpls-te-attribute-set)# autoroute announce\nRouter(config-mpls-te-attribute-set)# auto-bw collect-bw-only\nRouter(config)# commit \n</code></pre> <p>We want to:</p> <ol> <li>Configure attribute set</li> <li>Enter automesh ID range and timers</li> <li>Configure a mesh group ID with a prefix-list that defines included routers</li> </ol> <p>A prefix-list can be configured on each TE router to match a desired set of router IDs. Then if you want to add a new router to the autotunnel mesh, add it into the prefix-list (or number it with an IP within the defined range). This enables provisioning requirement only on the added router, not all other routers too.</p>"},{"location":"MPLS%20TE/#mpls-te-end-to-end-path-protection","title":"MPLS TE End-to-End Path Protection","text":"<p>Path protection provides an end-to-end failure recovery mechanism for MPLS-TE tunnels. A secondary Label Switched Path (LSP) is established, in advance, to provide failure protection for the protected LSP that is carrying a tunnel's TE traffic.</p> <p>Path protection characteristics:</p> <ul> <li>Protection of a Cisco MPLS TE path is provided end-to-end.</li> <li>Primary is the regular LSP, while protected is the backup LSP.</li> <li>Both tunnels are signaled, including protected to minimize on the failover time.</li> <li>Headend is notified of the failure through RSVP, BFD, or IGP.</li> <li>Path protection and FRR can be configured on the same tunnel at the same time with these benefits:<ul> <li>Protection is expanded.</li> <li>Quick and effective re-optimization.</li> <li>Total time on backup is reduced.</li> </ul> </li> </ul> <p>Although not as fast as link or node protection, presignaling a secondary LSP is faster than configuring a secondary primary path option, or allowing the tunnel source router to dynamically recalculate a path. The actual recovery time is topology-dependent, and affected by delay factors such as propagation delay or switch fabric latency.</p> <p>Effectively, path protection switch over replaces the post-FRR LSP down event reoptimization</p> IOS XR from Cisco.com<pre><code># A mesh of R1-R2-R3-R4, here we connect R1 - R4 tunnel, then protected backups.\nRouter # configure\nRouter(config)# interface tunnel-te 0 \nRouter(config-if)# destination 192.168.3.3\nRouter(config-if)# ipv4 unnumbered Loopback0\nRouter(config-if)# autoroute announce\nRouter(config-if)# path-protection\nRouter(config-if)# path-option 1 explicit name r1-r2-r3-00 protected-by 2\nRouter(config-if)# path-option 2 explicit name r1-r2-r3-01 protected-by 3\nRouter(config-if)# path-option 3 explicit name r1-r4-r3-01 protected-by 4\nRouter(config-if)# path-option 4 explicit name r1-r3-00 protected-by 5\nRouter(config-if)# path-option 5 explicit name r1-r2-r4-r3-00 protected-by 6\nRouter(config-if)# path-option 6 explicit name r1-r4-r2-r3-00 protected-by 7\nRouter(config-if)# path-option 7 dynamic\nRouter(config-if)# exit\nRouter(config)# commit\n</code></pre>"},{"location":"MPLS%20TE/#bfd-for-mpls-te-lsp","title":"BFD for MPLS TE LSP","text":"<p>BFD is quicker, lighter, than LSP ping messages. Helps tear down tunnel-te interfaces more quickly in failure conditions to prevent traffic black holing and detect link failures more quickly.</p> IOS XR<pre><code>interface tunnel-te 10\n  bfd\n    multiplier 5\n    fast-detect\n    minimum-interval 200\n  !\n!\n</code></pre>"},{"location":"Multicast/","title":"Multicast","text":""},{"location":"Multicast/#multicast-distribution-tree","title":"Multicast Distribution Tree","text":"<p>High level, multicast traffic is sent and distributed (forwarded) along a Multicast Distribution Tree (MDT). The MDT is the data plane.</p> <p>A source sends traffic into a MDT and receives join the MDT to receive traffic. </p> <p>In a MDT, a source sends traffic, and the first hop router (FHR) has a special role in creating the MDT. The sender does not use any control plane signaling, it just sends traffic. Although, sources can \"subscribe\" to a group (multicast address), and the source will send to that.</p> <p>Internet Group Management Protocol (IGMP) is used by receivers. On the network, PIM, and across multidomain networks, MP-BGP and Multicast Source Discovery Protocol (MSDP) are used.</p> <p> Below we will cover the different MDT's.</p>"},{"location":"Multicast/#ssm-distribution-tree-sg","title":"SSM Distribution Tree (S,G)","text":"<p>Source-specific Multicast (SSM) is commonly used for applications such as video or audio streaming, where a single source sends to a group of receivers. The receivers join explicitly to this single source. </p> <p>Receivers join a specific group, referred to as (Source,Group) or (S,G). This (S,G) state must be kept in the network, and thus impacts resource consumption on routers. Every new unique (S,G) entry will lead to more state on the network.</p> <p>SSM may not scale well in all cases. If a receiver requests to join multiple sources, it will create (S2,G2), (S3,G3), etc. There will be several sources streaming to the same group. Any Source Multicast (ASM) is preferred here to create a shared MDT. </p>"},{"location":"Multicast/#asm-distribution-tree-g","title":"ASM Distribution Tree: (*,G)","text":"<p>ASM is commonly used for video conferencing, or applications with several sources in the same group. In this mode, a receiver joins any source in a specific multicast group.</p> <p>The source is joining all sources, as it is (*,G). In ASM, all traffic from all sources is first sent to a Rendezvous Point (RP).</p> <p>Receivers will send a Join request to the RP, and then a shared MDT is created from the RP to the receiver. In some cases, this could result in sub-optimal routing/delay between sources and receivers due to RP.</p>"},{"location":"Multicast/#loop-avoidance-in-mdt","title":"Loop Avoidance in MDT","text":"<p>In unicast, the routing protocol checks for loops. In multicast, a different mechanism must be used: Reverse Path Forwarding (RPF).</p> <p>RPF works in the following way:</p> <ul> <li>For each incoming multicast packet, the router looks up the source address in the unicast routing table. It looks for which interface it would use, if it were to send a normal unicast packet to that source.</li> <li>If the packet was received on the same interface, it is accepted.</li> <li>If the packet arrived on any other interface, it is dropped. In this case, it has come from another router which is not directly in the path. Forwarding such a packet would lead to a multicast routing loop. </li> </ul> <p> An example would be (S,G) of (192.0.100.1,239.1.1.1) coming into R1 on Gi0/1 interface.</p> <p>RPF would work like-- unicast routing lookup on 192.0.100.1. R1 RIB shows Gi0/2 for 192.0.100.0/24. RPF fails and packets discarded.</p>"},{"location":"Multicast/#multicast-ip-ranges","title":"Multicast IP ranges","text":"<p>Multicast traffic is sent to specific multicast addresses. The group G in (S,G) and (*.G) is such a multicast address.</p> Multicast Range Description Notes <code>224.0.0.0 - 224.0.0.255</code> Local Network Control Block Never routed, strictly link local <code>224.0.1.0 - 224.0.1.255</code> Internetwork Control Block Can be routed, internet control block <code>224.0.2.0 - 224.0.255.255</code> AD-HOC Block 1 Legacy assignments by IANA <code>224.2.0.0 - 224.2.255.255</code> SDP/SAP Block per rfc5771 For apps that use SDP/SAP <code>224.3.0.0 - 224.4.255.255</code> AD-HOC Block 2 Legacy assignments by IANA <code>232.0.0.0 - 232.255.255.255</code> Source-Specific Multicast 232/8 All SSM groups must use this range <code>233.0.0.0 - 233.251.255.255</code> GLOP Block inter-AS multicast traffic but doesn't work with 4 byte ASN's <code>233.252.0.0 - 233.255.255.255</code> AD-HOC Block 3 Assignments by IANA for stuff <code>234.0.0.0 - 234.255.255.255</code> Unicast-Prefix-based IPv4 Multicast addresses rfc6034 <code>239.0.0.0 - 239.255.255.255</code> Organization-Local Scope Loosely intended to be \"private multicast addresses\" <p></p>"},{"location":"Multicast/#igmp","title":"IGMP","text":"<p>The IGMP is the protocol between receivers and the last hop routers. It lets receivers subscribe to groups, and when they are done, it lets those receivers stop receiving the traffic later on.</p> <p>The IGMP is a control plane protocol that allows receivers to signal their interest in specific multicast groups. It runs exclusively between receivers and a last hop router, using link local or multicast addressing.</p> <p>IGMPv1: no longer used. Many drawbacks.</p> <p>IGMPv2: most commonly supported today, but it does not support SSM.</p> <p>IGMPv3: most recent with features + SSM support.</p> <p>IGMP running on a router is always backwards compatible. A router with v3 can talk to a receiver using v1 or v2.</p>"},{"location":"Multicast/#igmpv2","title":"IGMPv2","text":"<ul> <li>Receivers can join and leave a group<ul> <li>Version 2 membership report (type value 0x16): called IGMP Join; used by Receivers to join a multicast group or to respond to a local router's membership query </li> <li>Version 1 membership report (0x12): used by Receivers for backward compatibility with IGMPv1 </li> <li>Version 2 leave group (0x17): Receivers indicate they want to stop multicast traffic from a group they joined  </li> </ul> </li> <li>Queriers (last-hop routers):<ul> <li>There are two type of queries, general membership query and group specific query.</li> <li>If a LHR receives a \"leave\" message from one of the receivers on the subnet, it will send a general membership query to try and prune but wait for potential membership report(s) from receivers.</li> <li>General membership query (0x11): sent to All-Hosts group address 224.0.0.1 to see if there are any Receivers on attached subnet; group address field is set to 0.0.0.0 </li> <li>Group specific query (0x11): sent in response to a leave group message to group address they requested to leave </li> </ul> </li> </ul> <p>Ohter information, the max response time: max time before sending a response report; typically 10s.</p>"},{"location":"Multicast/#igmpv3","title":"IGMPv3","text":"<p>Same but more. Allows receivers to:</p> <ul> <li>Join specific sources, which is required for SSM. \"source S1, S2, S3\", \"all sources except S2\".</li> <li>Source filtering, can listen to (S1, G) but filter (S2,G)</li> </ul> <p>Backwards compatible with v2 and new fields added to Membership Query and v3 Membership Report.</p> <p>SSM allows for the creation of source distribution trees without the need for a Rendezvous Point (RP).</p> <p></p>"},{"location":"Multicast/#asm-v-ssm","title":"ASM v SSM","text":"<p>Multicast has two fundamental architectural methods to create a MDT. In ASM, the network finds the sources, as receivers join (*,G) so receivers join all sources at once in a shared tree. For SSM, the receiver joins an explicit source (MDT) so complexity is lower to deliver packets, especially for inter-domain topologies.</p> <p>SSM is usually prefered, but there can be more state to manage on the routers. </p>"},{"location":"Multicast/#ssm","title":"SSM","text":"<p>Receiver driven, so the flow starts from receiver side.</p> <ul> <li>The receiver learns about the source and group address out-of-band (OOB), from a web page, an application, or similar.</li> <li>The app in the receiver then sends an IGMPv3 membership report to the last hop router. In this request, it specifies the specific (S,G) that it wants to receive traffic from. </li> <li>PIM join messages from LHR are sent hop by hop, to \"all PIM routers\" in a multicast group 224.0.0.13. The next hop is determined by a lookup in the unicast routing table. This method will send PIM join messages hop by hop, until the first hop router is reached. This leads to the optimal path of the source (as defined in the unicast table), while on each router on the way\u2014multicast forwarding state is established.</li> <li>The source sends multicast stream to FHR</li> </ul> <p>When a LHR has no more receivers, it sends a PIM Prune message upstream to stop the multicast stream.</p>"},{"location":"Multicast/#asm","title":"ASM","text":"<p>In ASM a receiver does not join a specific source, but just a group (*,G). So how does the network know what sources to send if it gets no instructions from the receivers?? It finds them using a RP for receivers. </p> <p>Step one, a PIM join is sent from the LHR to the RP. This builds a \"source specific tree\" to the RP (intermediate source). </p> <p>The process is the same as SSM, the application in the receiver then sends an IGMP membership report (version 2 or version 3) to the last hop router. In this request it specifies the group (*,G) it wants to receive traffic from.</p> <p>As in SSM, PIM join messages are sent hop by hop, to the \"all PIM routers\" multicast group 224.0.0.13. In ASM however, the messages are sent toward the RP, because the last hop router does not know the source yet. The next hop is determined by a lookup of the RP in the unicast routing table. This method will send PIM join messages hop by hop, until the RP is reached. This leads to the optimal path to the RP, while on each router on the way\u2014multicast forwarding state is established.</p> <p>Now the RP has a shared source tree to all receivers. </p> <p>Step two, a source starts forwarding multicast stream. In ASM, FHR sends the multicast traffic through a unicast tunnel to the RP, using PIM-register messages. This informs the RP about the source.</p> <p>Next, the RP uses the previously established Shared Tree to forward to receivers.</p> <p>Now, the sources and receivers are linked, but it could be sub-optimal. Is the route between source - RP - receiver the best? Also, traffic between the source and RP is still in the unicast tunnel.</p> <p>Step three, the RP sends back PIM-register messages to the source. When the FHR has the native multicast state installed, it starts to send multicast in parallel with the unicast traffic. Once the RP receives the multicast traffic, it will signal the FHR to stop the tunnel with a PIM register-stop message. </p> <p>Now there are two distinct trees: (1) Source to RP, (2) RP to receiver</p> <p>Step four, the LHR will be made aware of the source addresses as traffic is forwarded to it via step 2 above. The LHR will send direct (S,G) to each source. This will result in a source distribution tree, then PIM will naturelly prune paths no longer used. </p>"},{"location":"Multicast/#intradomain-and-interdomain-multicast","title":"Intradomain and Interdomain Multicast","text":"<p>Interdomain multicast routing architecture allows for an administrative and secure separation between domains while allowing for direct multicast between domains.</p> <p>There are challenges with routing between interdomain RPs, and the signaling and data plane functionality of PIM with RPs can allow receivers and sources to just start sending with any controls. This is a utilization/capacity risk and access risk.</p> <p>Within a sinle domain, IGMPv2/v3 (between receivers - routers), PIM-SM (between routers) is used for multicast. </p> <p>For interdomain, there is:</p> <p>MP-BGP: Multiprotocl-BGP (MP-BGP) supports many address-families in parallel, and it used to advertise prefixes for multicast traffic between domains. It allows for two routing tables, such that multicast traffic can be routed over another link from unicast traffic. It it still a unicast routing table though, but when PIM creates the MDT, it can use the MP-BGP multicast table for the RPF check.</p> <p>PIM-SM: used to create MDTs between routers across domains.</p> <p>Multicast Source Discovery Protocol (MDSP): used to connect different PIM-SM domains. It allows sources in one PIM-SM domain to be discovered by RPs in other PIM-SM domains.      - When a new multicast source starts sending traffic in a PIM-SM domain, the FHR registers the source with its local RP using a PIM Register message.     - The local RP then uses MSDP to advertise this new multicast source to MSDP peers in other PIM-SM domains.     - The MSDP peers then inform their local RPs about the new source, allowing them to join the source-specific distribution tree.     - This way, MSDP enables RPs in different PIM-SM domains to learn about active multicast sources, allowing receivers in one domain to join and receive multicast traffic from sources in other domains.</p>"},{"location":"Multicast/#more-on-msdp","title":"More on MSDP","text":"<p>RP operators want to secure and run their own RPs, they do not want to \"share\" a RP with another domain. So, MSDP allows RPs in different domains to continue working the same for intradomain multicast. </p> <p>An RP in a PIM-SM domain has MSDP peering relationships with MSDP-enabled routers in other domains. Each peering relationship occurs over a TCP connection, which is maintained by the underlying routing system. </p> <p>MSDP speakers exchange messages called Source Active (SA) messages. When an RP learns about a local active source, typically through a PIM register message, the MSDP process encapsulates the register in an SA message and forwards the information to its peers. The message contains the source and group information for the multicast flow, as well as any encapsulated data. If a neighboring RP has local joiners for the multicast group, the RP installs the (S,G) route, forwards the encapsulated data contained in the SA message, and sends PIM joins back towards the source. </p> <p>SA messages contain the following fields:</p> <ul> <li>Source address of the data source.</li> <li>Group address that receives data sent by the source.</li> <li>IP address of the RP.</li> </ul> <p>Routing is then done via underlying routing protocol(s), although it is recommended to use MP-BGP, it is not 100% necessary.</p>"},{"location":"Multicast/#interdomain-shared-mdt-creation","title":"Interdomain Shared MDT creation","text":"<ul> <li>When a source\u2019s first data packet is registered by the first hop router, the RP extracts the data from the packet and forwards it down the shared tree in the PIM domain.</li> <li>The RP informs MSDP peers of the new source by sending a Source-Active (SA) message that identifies the source, the recipient group, and the RP\u2019s address or originator ID.</li> <li>Upon receiving the SA message, an MSDP peer which is the RP for a multicast tree that includes members interested in the multicast sends a PIM join message (S,G) toward the data source.</li> <li>After the RP on another domain joins the PIM Designated Router (DR) in the first domain, multicast data traffic flows natively over the multicast tree to the second domain's RP.</li> <li>If the source times out, this process repeats when the source goes active again. </li> </ul>"},{"location":"Multicast/#interdomain-ssm","title":"Interdomain SSM","text":"<p>Much more simple. There is no requirement for RPs, thus no MDSP. However, routing still has to happen, so MP-BGP is still required to keep the multicast source table separate from the unicast one. And PIM-SM is used to create the MDT.</p> <p>IPv6 does not use MDSP, since IGMP is a IPv4-only. IPv6 receivers use Multicast Listener Discovery (MLD), which does not require the usage of MDSP.</p> <p></p>"},{"location":"Multicast/#multicast-ip-layer-3-to-layer-2-mapping","title":"Multicast IP Layer 3 to Layer 2 Mapping","text":"<p>Layer 2 has its own multicast scheme, developed independently from IP multicast at layer 3.</p> <p>Layer 2 MAC addresses have 6 bytes (48 bits), where 25 bytes are fixed, leaving effectively 23 bits for the Layer 2 multicast address.</p> <p>IPv4 multicast addresses use 4 bytes (32 bits), of which 4 bits at the beginning are fixed (\"1110\") to indicate that it is a multicast address, leaving 28 bits for effective addressing.</p> <p>32 (2^5) IP addresses map into each one of the Ethernet addresses. This does not cause any functional problems, but it may lead to sub-optimal multicast traffic distribution. Several multicast streams may be delivered to an endpoint, even though it only subscribed to one. However, the endpoint would just discard unneeded traffic. Since this happens typically on the switch before the endpoint, there is normally no problem. </p>"},{"location":"Multicast/#igmp-snooping","title":"IGMP Snooping","text":"<p>IGMP snooping sest up Layer 2 multicast forwarding tables to deliver traffic only to ports with at least one interested member, significantly reducing the volume of multicast traffic. IGMP snooping uses the information in IGMP membership report messages to build corresponding information in the forwarding tables to restrict IP multicast traffic at Layer 2.</p> <p>Without IGMP snooping, a switch will forward a copy of multicast packet to all network interfaces. </p> <p>rfc4541 discusses this further.</p>"},{"location":"Multicast/#pim-snooping","title":"PIM Snooping","text":"<p>If there are several routers connected to a L2 switch, that switch does not know which routers are subscribed to the multicast traffic. It is a similiar problem, so a similiar solution was created with PIM snooping.</p> <p>With PIM snooping the switch interprets all Layer 3 PIM messages. This way it learns which router wants to subscribe to which group and can forward the multicast traffic only to the correct ports.</p> <p>PIM snooping can be enabled globally on a switch, or per interface. </p> <p><code>ip pim snooping</code></p> <p><code>interface vlan 4090</code> <code>ip pim snooping</code></p>"},{"location":"Multicast/#multipoint-ldp","title":"Multipoint LDP","text":"<p>Label Switch Multicast (LSM) is MPLS technology extensions to support multicast using label encapsulation.</p> <p>This allows for the setup of point-to-multipoint (P2MP) and multipoint-to-multipoint (MP2MP) Label Switched Paths (LSPs) in MPLS networks. These extensions are also referred to as multipoint LDP. These LSPs can be used for transporting both IPv4 and IPv6 multicast packets, either in the global table or VPN context.    </p> <p>Just like in standard multicast (outside MPLS), the MPLS core unicast routing and switching is also required to support multicast traffic. So Multipoint LDP runs in parallel. In LSM with multipoint LDP, the same control and data plane is used as in the unicast MPLS core.  The overall application is called multicast VPN (MVPN). </p> <p>FRR can be used. </p>"},{"location":"Multicast/#lsm-packet-forwarding","title":"LSM: Packet Forwarding","text":"<p>For each packet coming in, MPLS creates multiple out-labels. If you were to look at a MDT in <code>show mpls forwarding table</code>, you could observe two outgoing labels over two different out interfaces. This indicates a point-to-multipoint LSP.</p> <p>From the perspective of the source and receivers, things are unchanged. The PE routers talk PIM with each other then downstream to their CE's, then between the PE's is the provider core that is multipoint LDP aka Label Switch Multicast.</p> <p></p>"},{"location":"Multicast/#pim-sim-overview","title":"PIM-SIM Overview","text":"<p>PIM is the most important protocol for multicast to function properly. The most common is <code>PIM-Sparse Mode (SM)</code>, and there is <code>PIM-Dense Mode (DM)</code> but mostly that is deprecated. PIM-SM with ASM is more optimal shared MDT.</p> <p>Some terms:</p> <ul> <li>Reverse Path Forwarding (RPF) Interface: interface with lowest cost path (AD + metric) to IP address of the Source (SPT) or the RP (shared trees) </li> <li>RPF neighbor: PIM neighbor on a RPF interface </li> <li>Upstream: towards the Source of the tree; a PIM Join travels upstream </li> <li>Downstream: towards Receivers  -Downstream Interface / Outgoing Interface (OIF): used to forward multicast traffic towards Receivers or down the tree from Source </li> <li>Incoming Interface (IIF): only interface that can accept multicast traffic from Source, which is the same as the RPF interface </li> <li>Outgoing Interface List (OIL): a list of OIF's forwarding multicast traffic to the same group address </li> <li>Last-Hop Router (LHR): router directly attached to Receivers; responsible for PIM Join upstream </li> <li>First-Hop Router (FHR): router directly attached to Receivers; sending Register msg to RP </li> </ul> <p>PIM-SM is used in ASM.</p> <ul> <li>ASM requires a RP<ul> <li>RP can be statically configured everywhere, or there are dynamic methods with Auto-RP or PIMv2 bootstrap mechanism</li> <li>RP helps sources find receivers by creating a MDT</li> </ul> </li> <li>Initial flow is a shared tree down to receivers, then the LHR will optimize it by joining the source tree (SPT) directly to the source<ul> <li>Shared tree is a Shortest Path Tree (SPT) to the source, then down to the receivers is a shared tree.</li> </ul> </li> </ul>"},{"location":"Multicast/#packet-flow-for-pim-sm-and-asm","title":"Packet flow for PIM-SM and ASM","text":""},{"location":"Multicast/#receiver-shared-tree-join","title":"Receiver shared tree join","text":"<p>Receiver sends an IGMP membership join to (*,G). This is, send me any source to group G. </p> <p>LHR knows about the RP through config. It does a route lookup, then sends PIM join upstream to the RP. Most PIM messages are link local multicast 224.0.0.13 (<code>All-PIM</code>).</p> <p>As the PIM join travels upstream from LHR to RP, routers create multicast state for (*,G). The interface that the PIM join was received on becomes the OIL maintained by routers.</p> <p>The PIM Join reaches the RP, and the shared tree is formed between receiver(s) and RP.</p>"},{"location":"Multicast/#source-registration","title":"Source Registration","text":"<p>Sources do not use a protocol to communicate with the network. They send multicast network, and the network does the rest.</p> <p>When the FHR sees traffic to a multicast address, it checks if this is new or already existing. If there is no state, it sends a PIM-Register to the RP for group G (a mcast address).</p> <p>Except, the source is already forwarding mcast traffic??!! so how can the network forward this traffic along a not pre-existing MDT?</p> <p>Answer, high level, is that the FHR forwards the multicast traffic from the source encapsulated in unicast (!) PIM register messages to the RP. Once the RP receives such register messages, it decapsulates the packet and sends them down the shard tree to the receivers.</p> <p>In parallel, the RP builds a (S,G) shortest path tree (SPT) back to the source. When done, there is a switchover to the SPT and unicast PIM Register tunnel is stopped.</p>"},{"location":"Multicast/#pim-sm-switchover","title":"PIM-SM Switchover","text":"<p>LHR can decide to build a SPT back to source instead of using the shared tree via RP, <code>always</code> by default, or by configuration, it can be <code>threshold</code> or <code>never</code>. </p> <p>PIM Joins are sent hop by hop to the source, creating a new specific (S,G) SPT. </p> <p>For a period of time, multicast traffic will be duplicated down the RP SPT + RP-&gt;G shared tree and the new switchover SPT. The LHR will eventually receive the same multicast traffic from two interfaces, one on the RP-based shared tree, and one on the source-based SPT.</p> <p>The switchover process to a SPT is triggered by a data bandwidth that exceeds the configured limit (or, if none is configured, immediately). The behavior can be configured per group. The LHR will set a <code>J</code> flag on (*,G) in the multicast routing table. If the threshold is set to <code>infinity</code>, then there will never be a switchover to join the SPT instead of shared tree.</p> <p>To optimize, it now sends another PIM message along the shared tree, to prune (stop) receiving the specific (S,G) from the shared tree. Note that in ASM, there may be several sources, thus the prune must be specifically for the source. This is a specific (S,G) RP-bit Prune message to the RP. </p> <p>When the PIM Prune message reaches the RP, it checks if there are any other OIL for that group. If no, then RP will prune back to source.</p> <p></p>"},{"location":"Multicast/#pim-sm-packets-and-state","title":"PIM-SM packets and state","text":"<p>The more optimal the traffic flows for multicast traffic, the more state on the network needs to be maintained.</p> Packet Name Destination Description PIM Hello 224.0.0.13 (All-PIM-Routers) Establishes PIM adjacencies between neighbors PIM Join/Prune Upstream PIM neighbor (unicast) Joins or prunes multicast distribution trees PIM Register Rendezvous Point (unicast) Encapsulates multicast data from source to RP PIM Register-Stop First-hop router (unicast) Tells first-hop router to stop sending Register messages PIM Assert 224.0.0.13 (All-PIM-Routers) Resolves forwarding conflicts on multi-access networks PIM Bootstrap 224.0.0.13 (All-PIM-Routers) Distributes RP information in a PIM domain PIM Candidate-RP-Advertisement Bootstrap Router (unicast) Informs BSR about candidate RPs PIM State Refresh 224.0.0.13 (All-PIM-Routers) Maintains source state in PIM-DM domains (when enabled)"},{"location":"Multicast/#pim-neighbor-discovery","title":"PIM neighbor discovery","text":"<p>PIM will establish neighbor adjacencies and elect a DR on each segment. The router with the highest IP address (or, if configured, the highest DR priority), is chosen as a DR. It is this router that will send PIM joins upstream. </p> <p>This is <code>PIM Hello</code> to 224.0.0.13. </p>"},{"location":"Multicast/#pim-sm-forwarding","title":"PIM-SM forwarding","text":"<p>Multicast traffic forwarding is controlled by the OIL. Packets are sent out all interfaces on the OIL. </p> <p>There are three ways to put an interface on the OIL for a given multicast group:</p> <ol> <li>When a PIM join for this group is received on this interface. The PIM join indicates that there are receivers further down that interface.</li> <li>When an IGMP message has been received, indicating that a receiver joined on this segment.</li> <li>There is also the possibility to statically join a group on an interface, via configuration. </li> </ol> <p>Expiration timers are reset depending on the type:</p> <ul> <li>(S,G) timers are reset when a multicast packet is forwarded. So as long as there is traffic, the state is maintained.</li> <li>(*,G) timers are reset when a periodic PIM join is received for (*,G). So as long as receivers are interested in this group, the state is maintained, independently of traffic sent. </li> </ul>"},{"location":"Multicast/#pim-sm-join-process","title":"PIM-SM Join process","text":"<p>PIM-SM Joins travel from receivers up to RP and/or the source.</p> <p>In ASM, (*,G) creates state at each hop:</p> <ul> <li>IF there is no (*,G) state, router processing the PIM Join will create it, add interface to OIL, send PIM Join to RP</li> <li>ELIF there is (*,G) state, add interface to OIL. PIM Join process is complete, as there is already a built Shared tree</li> <li>Period (*,G) PIM Joins refresh interfaces in the OIL between PIM neighbors</li> </ul>"},{"location":"Multicast/#pim-sm-state-tables-for-all-mdts","title":"PIM-SM state tables for all MDTs","text":"<p>The Multicast Routing Information Base (MRIB) is a protocol-independent multicast routing table that is created by PIM. It is composed of (S,G) or (*,G) entries with <code>Incoming interface</code>, <code>RPF neighbor</code>, then the <code>OIL</code>.</p> <p><code>show ip mroute</code> for IOS</p> <p><code>show mrib ipv4 route</code> on IOS-XR</p> <p>So for an incoming multicast packet (possibly even the first one!!)...</p> <ol> <li>if (S,G) exists for specific Source and Group, use this</li> <li>if (*,G) exists for that Group, use this</li> <li>if there is no entry, then the source must have just started sending and you are the FHR, congrats. The router (now the FHR) uses PIM Register packet to encapsulate and forward traffic to the RP.</li> </ol> <p></p>"},{"location":"Multicast/#pim-sm-and-receivers","title":"PIM-SM and Receivers","text":"<p>Receivers uses IGMP to communicate their Joins and to talk with the LHR. In ASM, IGMPv2 is sufficient, IGMPv3 is however backward compatible and can also be used. In ASM, a receiver joins a (*,G): any source sending to group G. When the LHR sees an IGMP message for a group G, it will add the interface on which this IGMP message was received to the OIL for the group.</p>"},{"location":"Multicast/#pim-sim-and-source-registration","title":"PIM-SIM and Source Registration","text":"<p>When a source starts to send, the network must register the source with the RP. THe FHR plays this role. It will encapsulate and forward source multicast traffic to the RP in PIM Register unicast packets.</p> <p>There can be some weird scenarios, like say, there are 3 routers:</p> <p>(<code>source</code>) - [<code>R1</code> (FHR)] - [<code>R2</code>] - [<code>R3</code> RP] - [Rest of provider network down to PE and CE] - (<code>receiver 1</code>)</p> <p>Attached to R2 is a new ASM receiver that wants to join group G. There is already state for (S,G) on router B, so at first it seems that the only action needed on B is to add another interface to the OIL for the (S,G). However, the ASM group G may have more sources sending to the group. To be sure to find them all, the receiver must join the shared tree toward the RP! </p> <p></p>"},{"location":"Multicast/#pim-sm-pruning-in-asm","title":"PIM-SM Pruning in ASM","text":"<p>Pruning can happen explicitly, by sending PIM prune messages, or implicitly, using a time-out. This section explains how pruning works in an ASM environment. </p> <p>In ASM, if a receiver leaves a group, it may not trigger a Prune. When all receivers on a segment leave group G, then all interfaces are removed from OIL for entries (*,G) and (S,G). Only once the last OIL is removed while the LHR send a PIM Prune message on the incoming interface for (*,G).</p> <p>Explicit prunes are only sent for (*,G) entries, which are only sent towards the RP (RP address noted in mroute table). (S,G) entries are left to time out.</p> <p></p>"},{"location":"Multicast/#pim-sm-implementation","title":"PIM-SM Implementation","text":"IOS XR<pre><code>hostname R1-XR\nipv4 access-list PIM_FILTER\n  permit host 10.1.1.2\n!\nmulticast-routing\n  address-family ipv4\n    interface all enable \n    interface Gi0/1\n      enable\n!\nrouter pim address-family ipv4\n  neighbor-filter PIM_FILTER\n  interface Gi0/1\n    enable\n  rp-address 10.1.1.1\n  spt-threshold [kbps | infinity]\n</code></pre> IOS XE<pre><code>hostname R2-XE\naccess-list 1 permit host 10.1.1.1\n!\nip multicast-routing\nip pim neighbor-filter 1\nip pim spt-threshold [kbps | infinity]\nip pim rp-address 10.1.1.1\n!\ninterface Gi0/0\n  ip pim sparse-mode\n!\n</code></pre>"},{"location":"Multicast/#show-commands-that-are-useful","title":"Show commands that are useful","text":"<p>IOS-XE <code>show ip pim interface</code> <code>show ip pim neighbor</code> <code>mrinfo $ip_address</code> <code>show ip pim rp</code> <code>show ip rpf</code> <code>show ip mroute</code></p> <p>IOS-XR <code>show pim interface</code> <code>show pim neighbor</code> <code>mrinfo $ip_address</code> <code>show pim topology</code> <code>show pim rpf</code> <code>show mrib route</code></p> <p></p>"},{"location":"Multicast/#source-specific-multicast-ssm","title":"Source-Specific Multicast (SSM)","text":"<p>When there are only one or a few sources sending multicast, ASM is probably too complex and unnecessary. SSM does not require a RP, and there is a single MDT for each source. No shared (*,G) trees are built or used. Since are no RP's, for inter-domain routing, there is no need for Multicast Source Discovery Protocol (MSDP). Both ASM and SSM can coexist on the network though.</p> <p>232.0.0.0/8, FF3x::/32 are used for SSM groups.</p> <p>SSM is an enhancement to PIM, written as PIM-SSM usually. PIM-SSM is made possible by IGMPv3 and MLDv2.</p> <p>The network service identified by (S,G), for SSM address G and source host address S, is referred to as a \"channel\".</p> <p>A high level SSM flow:</p> <ol> <li>A receiver learns about (S1,G) and (S2,G) from an out-of-band method, like a web page. <ul> <li>(S1,G) and (S2,G) are different channels, so they would be different trees.</li> </ul> </li> <li>The receiver sends IGMPv3 \"membership report\" requesting to join these groups specifically. </li> <li>LHR receives the IGMPv3 \"membership report\", then creates state for the requested channels. It adds the interface the IGMPv3 packet was received on to the OIL.</li> <li>The LHR creates a PIM (S,G) join message upstream. The upstream router is determined by the source IP address, which is a unicast table lookup to the source at each router in the path.</li> <li>The result will be a shortest path tree (SPT) to the FHR next to the source. </li> </ol> <p>The network keeps state for every (S,G) channel independently. So, for a multicast group with many sources, each source within that group would end up with its own SPF tree in SSM. Therefore, SSM is not optimal for multicast distributions where many sources send to the same group. </p>"},{"location":"Multicast/#igmpv3_1","title":"IGMPv3","text":"<p>IGMP has no transport (L4), like ICMP. It uses IP protocol 2</p> Packet Type Message Name Description 0x11 Membership Query Sent by routers to query group membership 0x16 v2 Membership Report Sent by hosts to join group also called <code>IGMP Join</code> 0x17 v2 leave group Sent by hosts to stop mcast traffic from a group they joined 0x22 Version 3 Membership Report Sent by hosts to report group membership 0x30 Multicast Router Advertisement Sent by routers to advertise their presence 0x31 Multicast Router Solicitation Sent by hosts to solicit router advertisements 0x32 Multicast Router Termination Sent by routers to indicate they are leaving the network"},{"location":"Multicast/#ssm-mapping","title":"SSM Mapping","text":"<p>If not all end hosts support IGMPv3, then those devices cannot subscribe to SSM channels because they cannot request (S,G). Legacy group membership reports for groups in the SSM group range are mapped to a set of sources providing service for that set of (S,G) channels. </p> <p>Two ways to configure:</p> <ol> <li>Static</li> <li>DNS-based</li> </ol> IOS XR<pre><code>Router#configure\nRouter(config)#ipv4 access-list 4\nRouter(config-ipv4-acl)#permit ipv4 any 232.1.2.0 0.0.0.255\nRouter(config-ipv4-acl)#exit\nRouter(config)# multicast-routing\nRouter(config-mcast)#address-family ipv4\nRouter(config-mcast-default-ipv4)#ssm range 4\nRouter(config-mcast-default-ipv4)#exit\nRouter(config-mcast)#exit\nRouter(config)#router igmp\nRouter(config-igmp)#ssm map static 172.16.8.10 4\n*/Repeat the above step as many times as you have source addresses to include in the set for SSM mapping/*\nRouter(config-igmp)#int te0/0/0/3\nRouter(config-igmp-default-if)#static-group 232.1.2.10\nRouter(config-igmp-default-if)#commit\n\n# DNS-based\nRouter#config\nRouter(config)#domain multicast cisco.com\nRouter(config-igmp)#domain name-server 10.10.10.1\nRouter(config-igmp)#router igmp\nRouter(config-igmp)#ssm map query dns\n</code></pre> IOS XE<pre><code>Router# conf t\nRouter(config)# access-list 10 permit 232.1.2.10\nRouter(config)# ip igmp static ssm-map group-list ssm-source 10 172.16.8.10\nRouter(config)# ip igmp ssm-map enable \n\n\n# DNS-based\nRouter(config)# ip domain multicast ssm-map.cisco.com \nRouter(config)# ip name-server 10.48.81.21 # generic DNS server config\n</code></pre> <p>In examples above 172.16.8.10 = $source and 232.1.2.10 = SSM group</p> <p>For DNS-based dynamic mapping, a LHR takes the DNS-name from group address in the IGMPv2 Membership Report. The router looks up IP address resource records (IP A RRs) to be returned for this constructed domain name and uses the returned IP addresses as the source addresses associated with this group.</p>"},{"location":"Multicast/#configuring-ssm","title":"Configuring SSM","text":"<p>Most of the SSM config is shown above, but to summarize a generic PIM-SSM configuration, it will look like:</p> <p>IOS-XE: </p> <p><code>ip multicast-routing</code> <code>ip pim ssm default</code></p> <p>IOS-XR: <code>multicast-routing</code> <code>address-family</code> <code>ssm (allow-override) (range) (disable)</code> <code>interface $if</code> <code>enable</code></p> <p></p>"},{"location":"Multicast/#bidirectional-pim","title":"Bidirectional PIM","text":"<p>Hard to find good sources for material but https://www.cisco.com/c/en/us/td/docs/ios-xml/ios/ipmulti_pim/configuration/xe-3s/asr903/17-1-1/b-imc-pim-xe-17-1-asr900/m-bidirectional-pim.pdf looks good</p> <p>For applications with many endpoints that both send and receive, BIDIR-PIM was developed. In BIDIR-PIM, a host can be both a source and a receiver, or just one of the two. If a receiver starts also sourcing traffic, no additional state is required in the network. </p> <p>PIM Bidirectional (BIDIR) has one shared tree from sources to RP and from RP to receivers. This is unlike the PIM-SM, which is unidirectional by nature with multiple source trees - one per (S,G) or a shared tree from receiver to RP and multiple SG trees from RP to sources. </p> <p>PIM-SM loops are avoided with RPF check. BIDIR maintains loop-free topology with a Designated Forwarder (DF).</p> <p>The thing with many-to-many is that a not all sources and receivers can be both sending and receiving at the same time. The bidirectional \"sources\" can change, which is why the example of a video conference application is used. When there is a new speaker, there is a new sender/receiver. The \"bidirectional\" multicast flow will shift on the network, but the \"shared tree\" more or less stays the same.</p> <ul> <li>When a new source starts sending for a BIDIR-compatible application, then there will a new FHR, which will recreate the shared tree to/from the RP.</li> </ul>"},{"location":"Multicast/#designated-forwarder-df","title":"Designated Forwarder (DF)","text":"<p>Loop avoidance in BIDIR is via the DF. On each segment, a DF is elected, whom is responsible for forwarding multicast traffic in both directions to and from the RP.</p> <p>The algorithm to elect the designated forwarder is straightforward, all the PIM neighbors in a subnet advertise their unicast route to the rendezvous point and the router with the best route is elected. If there is a tie, highest IP address wins.</p> <p>This effectively builds a shortest path between every subnet and the rendezvous point without consuming any multicast routing state (no (S,G) entries are generated). The designated forwarder election mechanism expects all of the PIM neighbors to be BIDIR enabled</p>"},{"location":"Multicast/#bidir-forwarding-source","title":"BIDIR Forwarding - Source","text":"<p>When a source starts to send, BIDIR will forward multicast to the RP. Routers must known their RP, either through manual config or dynamic methods.</p> <p>Each router will create (*,G) multicast forwarding state. Except with BIDIR, there is no IIF (incoming interfaces), there is just <code>Bidir upstream</code>, always pointing to the RP. There is OIL, but it refers to the interface on which traffic from <code>$source</code> is received added to OIL (which is the DF).</p> <p>BIDIR works very with many-to-many applications, since there is only one (*,G) entry for each BIDIR group, which is the reason why BiDir is preferable with many sources: It creates significantly less state than PIM-SM or PIM-SSM. </p>"},{"location":"Multicast/#bidir-forwarding-receiver","title":"BIDIR Forwarding - Receiver","text":"<p>When a router receives IGMP Join for bidirectional group G, LHR determines if it is the DF. The multicast state <code>(*,G)</code> will be flagged for BIDIR. If there is not one, then it will check DF election state, which will inform it which router on the segment is DF.  </p> <p>When a router receives a Join or Leave message, and the router is not the DF for the receiving interface, the message is ignored. Otherwise, the router updates the shared tree in the same way as in sparse mode.</p> <p>At each hop, the interface that the join was received on is added to the OIL, like in normal PIM-SM operations. The result is an RP-based shared MDT, which is loop free, because only the DFs forward the joins (and later the traffic).</p> <p>This goes hop by hop effectively the same as PIM-SM up to the RP, which creates a shared tree that is loop-free.</p>"},{"location":"Multicast/#configuring-pim-bidir","title":"Configuring PIM-BIDIR","text":"IOS XE<pre><code>!\nip pim bidir-enable\nip pim rp-address 20.1.1.10 BIDIR-GROUPS bidir\n!\nip access-list standard BIDIR-GROUPS\n20 permit 225.0.0.0 0.255.255.255\n!\ninterface GigabitEthernet0/2/1\n  ip pim sparse-mode\ninterface GigabitEthernet0/2/4\n  ip pim sparse-mode\n!\n</code></pre> <p><code>show ip mroute</code> will show <code>Bidir-Upstream:</code></p> <p><code>show ip pim neigh</code> will show <code>B</code> flag that indicates Bidir <code>show ip pim int df</code> shows DF </p> <ul> <li>IOS-XR, supposedly PIM-BIDIR is enabled by default but... I don't see evidence of this. The Cat8000 router IOS-XR docs says, PIM-BIDIR is not supported! Just configure the RP to be Bidir compat.</li> </ul> IOS XR<pre><code>router pim address-family ipv4\n  rp-address 20.1.1.10 bidir\n</code></pre>"},{"location":"Multicast/#more-on-df","title":"More on DF","text":"<p>A DF is elected on each link for a specific RP. If there are more than 1 RP, there will be RP-specific DF's on each link. To optimise tree creation, it is desirable that the winner of the election process should be the router on the link with the \"best\" unicast routing metric (as reported by the MRIB) to reach the RP.</p> <p>Election updates usually occur only once, but they can be triggered if there are changes:</p> <ul> <li>Unicast metric change to reach the RP</li> <li>If the DF interface also becomes the interface to reach the RP</li> <li>A new PIM neighbor establishes on the segment</li> <li>Elected DF fails</li> </ul>"},{"location":"Multicast/#df-election-messages","title":"DF Election Messages","text":"<p>Offer <code>(OfferingID, Metric)</code></p> <ul> <li>Sent by routers that believe they have a better metric to the RPA than the metric that has been on offer so far.</li> </ul> <p>Winner <code>(DF-ID, DF-Metric)</code></p> <ul> <li>Sent by a router when assuming the role of the DF or when re-asserting in response to worse offers.</li> </ul> <p>Backoff <code>(DF-ID, DF-Metric, OfferingID, OfferMetric, BackoffInterval)</code></p> <ul> <li>Used by the DF to acknowledge better offers.  It instructs other routers with equal or worse offers to wait until the DF passes responsibility to the sender of the offer.</li> </ul> <p>Pass <code>(Old-DF-ID, Old-DF-Metric, New-DF-ID, New-DF-Metric)</code></p> <ul> <li>Used by the old DF to pass forwarding responsibility to a router that has previously made an offer.  The Old-DF-Metric is the current metric of the DF at the time the pass is sent.</li> </ul> <p>During initial election, the backoff interval is 3 times the offer interval. </p> <p>Different routers on a segment advertise their metric. If they receive an Offer with better metric, it will stop sending Offers (a backoff interval x3 Offer interval). </p> <p>If a \"winning\" router sends 3 uncontested Offers, it will then send a <code>Winner</code> packet with ID and metric to RP.</p> <p>If DF loses route to RP, it sends a new Offer with infinite metric, which triggers a re-election.</p> <p>If DF \"fails\", the routing change will trigger downstream routers on segment to re-elect based on metric change for route to reach RP.</p> <p></p>"},{"location":"Multicast/#interdomain-multicast","title":"Interdomain Multicast","text":"<p>Keep things simple. SSM for interdomain. Re-use existing protocols-- MP-BGP to carry multicast info.</p> <p>If ASM is required, RP's have to be involved. This requires Multicast Source Discovery Protocol (MSDP) to exchange source info between domains via RP's.</p>"},{"location":"Multicast/#ssm-for-interdomain","title":"SSM for interdomain","text":"<p>Not actually required to use MP-BGP to transport multicast NLRI's for a seperate multicast table. SSM and the RPF check can use the unicast routing table. </p> <p>On the AS border routers, <code>ip multicast-routing</code> must be configured, PIM SSM must be configured globally, and PIM-SM on every interface.</p> IOS XR<pre><code>router bgp 65000\n  address-family ipv4 unicast\n  address-family ipv4 multicast\n!\n  neighbor 192.0.2.1\n    remote-as 65001\n    address-family ipv4 unicast\n  neighbor 192.0.2.5\n    remote-as 65001\n    address-family ipv4 multicast\n!\n</code></pre> IOS XE<pre><code>router bgp 65001\n  neighbor 192.0.2.2 remote-as 65000\n  neighbor 192.0.2.6 remote-as 65000\n  address-family ipv4 unicast\n    neighbor 192.0.2.2 activate\n    no neighbor 192.0.2.5 activate\n!\n  address-family ipv4 multicast\n    neighbor 192.0.2.5 activate\n!\n</code></pre> <p><code>show bgp ipv4 multicast</code> to look at IPv4 multicast BGP RIB.</p> <pre><code>ip multicast-routing\n!\ninterface Gi0/1\n  description Backbone-other-Routers\n  ip pim sparse-mode\n!\ninterface Gi0/2\n  description Host-facing-LAN\n  ip pim sparse-mode\n  ip igmp version 3\n!\nip pim ssm default\n</code></pre>"},{"location":"Multicast/#asm-for-interdomain","title":"ASM for interdomain","text":"<p>MSDP is IPv4 only.</p> <ol> <li>Source starts sending. FHR sends PIM Register to local AS1 RP.</li> <li>Local AS1 RP informs MSDP peers about new source G-1.</li> <li>AS2 receiver joins (*,G-1) via IGMP</li> <li>PIM join travels to AS2 RP</li> <li>AS2 RP has learned about G-1 source from AS1 RP via MSDP, connects receiver to source G-1</li> <li>MDT gets built interdomain</li> </ol> IOS XE<pre><code>ip access-list extended MSDP_ACL\n  accept ip host 239.1.1.2\n  accept ip host 239.1.1.1\n!\nip msdp peer 192.0.2.1 connect-source Loopback0\nip msdp originator-id Loopback0\nip msdp ttl-threshold 192.0.2.1 140\nip msdp sa-filter in 192.0.2.1 list MSDP_ACL\nip msdp sa-filter out 192.0.2.1 list MSDP_ACL\nip msdp password peer 192.0.2.1 Cisco123\n</code></pre> <p>https://www.cisco.com/c/en/us/td/docs/routers/asr9000/software/24xx/multicast/configuration/guide/b-multicast-cg-asr9k-24xx/Implementing-layer3-multicast.html#task_2948296</p> IOS XR<pre><code>ipv4 access-list 100 20 permit 239.1.1.1 0.0.0.0\nipv4 access-list 100 30 permit 239.1.1.2 0.0.0.0\n!\nrouter msdp\n  originator-id Lo0\n  peer 192.0.2.2 \n    connect-source Lo0\n    ttl-threshold 8\n    password Cisco123\n    remote-as 65001\n  sa-filter in list 100\n  sa-filter out list 100\n</code></pre> <p><code>show msdp summary</code> to look at peers.</p> <p><code>show msdp sa-cache</code> to see what multicast state is being exchange.</p> <p><code>show msdp rpf</code> to view RPF lookup associated.</p>"},{"location":"Multicast/#multicast-architecture","title":"Multicast architecture","text":"<p>ASM deployments depend on RP placement and function, so ensuring HA is critical. </p> <p>Dynamic RP configurations are many-- <code>Auto-RP</code>, <code>BSR</code>, <code>Anycast RP</code>, but there are often drawbacks and restrictions.</p> <p>There is also Multicast NSF with stateful switchover (SSO).</p>"},{"location":"Multicast/#auto-rp","title":"Auto-RP","text":"<p>Cisco-only. It automates the distribution of group-to-RP mappings in a PIM network, or said another way, it allows routers to find RPs automatically for generic or specific groups. Highest IP address for any group via RP's will win and be chosen. Actually... that is kind of shit for design.</p> <p>This simplifies the configuration, and it can provide HA and other optimal design. It allows for load distribution, plus facilitates the arrangement of RPs according to the location of group participants. </p> <p>Configure routers as candidate RPs so that they can announce their interest (via <code>rp-announce</code> on 224.0.1.39) in operating as an RP for certain group ranges. </p> <p>Additionally, a router must be designated as an RP-mapping agent that receives the <code>rp-announce</code> messages from the candidate RPs, and arbitrates conflicts. The RP-mapping agent sends the consistent group-to-RP mappings to all remaining routers via <code>rp-discovery</code> on 224.0.1.40. Thus, all routers automatically determine which RP to use for the groups they support. </p> <p>A router can be configured to be both Candidate RP and mapping agents at the same time. </p> <p><code>rp-announce</code> message contains:</p> <ul> <li>group IP address range, default is 224/4</li> <li>IP address of candidate RP</li> <li>a holdtime used to detect failures, which is 3x the announcement interval (180s in total)</li> </ul>"},{"location":"Multicast/#configuring-auto-rp","title":"Configuring Auto-RP","text":"<p>For IOS-XE, there is a \"strange\" config requirement. Auto-RP requires PIM-DM to work. </p> <p>You could enable PIM-DM, but that's not a good idea, given how it works. So IOS-XE uses <code>ip pim autorp listener</code> and <code>ip pim autorp listener</code> to ensure Auto-RP 224.0.1.39 <code>rp-announce</code> and 224.0.1.40 <code>rp-discovery</code> are forwarded.</p> <p>IOS-XR does not support PIM-DM, but it has builtin exceptions to forward these.</p> IOS XR<pre><code>!\nrouter pim address-family ipv4\n  auto-rp candidate-rp GigabitEthernet0/1/0/1 scope 31 group-list 2 bidir\n  auto-rp mapping-agent GigabitEthernet0/1/0/1 scope 20\n!\nipv4 access-list 2\n  permit 239.1.1.1 0.0.0.0\n</code></pre> <p><code>scope</code> = TTL hops</p> IOS XE<pre><code>!\n# the below is required for IOS-XE to enable forwarding of 224.0.1.39 and 224.0.1.40 in dense mode on all multicast enabled interfaces. \nip pim autorp listener\n!\nip pim send-rp-announce Gi0/1 scope 31 group-list 10\nip pim send-rp-discovery Gi0/1 scope 20 group-list 20\n!\nip access-list standard 10\n  permit 239.1.1.1\n!\nip access-list standard 20\n  permit 192.0.2.120\n  permit 192.0.2.240\n</code></pre> <p><code>show ip pim rp mapping</code> on mapping-agent to look at specific RP's and their group announcements.</p>"},{"location":"Multicast/#some-best-practice-notes","title":"Some best practice notes","text":"<p>Like unicast, you should secure your multicast boundary, this includes control plane multicast traffic like Auto-RP. Explicitly filter and control which groups are allowed to cross domains and deny everything else.</p> <p>If there are RP's outside your control that you want to enable Auto-RP for some specific groups to work for, you can configure this...</p> <pre><code>interface GigabitEthernet0/0\n ip multicast boundary AutoRP-ACL-filter filter-autorp\n!\naccess-list AutoRP-ACL-filter permit 224.1.1.1\n</code></pre>"},{"location":"Multicast/#pimv2-bootstrap-router","title":"PIMv2 Bootstrap Router","text":"<p>RFC 5039; fault tolerant, automated RP discovery and distribution mechanism. It requires PIMv2, which BSR uses for BSR signalling, while Auto-RP can work with v1/v2.</p> <p>A single router is elected as the BSR from a collection of candidate BSRs. If the current BSR fails, a new election is triggered. The election mechanism is preemptive based on the priority of the candidate BSR.</p> <p>In order to determine the RP for a multicast group, a PIM router maintains a collection of group-to-RP mappings, called the <code>RP-Set</code>. A group-to-RP mapping contains the following elements.</p> <ul> <li>Multicast group range, expressed as an address and prefix length</li> <li>RP priority</li> <li>RP address</li> <li>Hash mask length</li> <li>SM / BIDIR flag</li> </ul> <p>All configured BSR routers send BSR messages on PIMv2 224.0.0.13, which has a TTL 1. BSR info is propagated via normal PIM methods. </p> <p>First, BSR routers send BSR messages throughout the PIM domain with the address of the BSR candidate sending the message and its priority.</p> <p>Second, all candidate BSR's send their <code>bsr-messages</code> with the <code>candidate</code> label. Similiar to other election protocols, candidates announce themselves until they hear a higher priority. </p> <ul> <li>If the priority of another candidate BSR is higher, it backs off.</li> <li>If the priority of another candidate is lower, it elects itself as the elected BSR.</li> <li>If the priority is the same, it decides on the IP address (like in Auto-RP)\u2014higher address wins. </li> </ul> <p>Next, third, RP candidates watch the BSR election waiting for a winner, an <code>elected BSR</code>. When candidate RPs see BSR messages from an elected BSR, they respond unicast to this BSR, with their role as candidate RP all group information they are configured with. </p> <p>Finally, fourth, the elected BSR sends the resulting RP to group mapping out to the rest of the multicast domain, again using the same PIMv2 BSR messages.</p> <p>Other routers utilize the RP-set info</p> IOS XE<pre><code>!\n# for RP-candidates\nip pim rp-candidate $interface\n!\n# for BSR candidates\nip pim bsr-candidate $interface\n!\ninterface Gi0/1\n  description Interdomain border\n  # stops bsr packets on inter-domain border\n  ip pim bsr-border\n</code></pre> IOS XR<pre><code>!\nrouter pim address-family ipv4\n  # for RP-candidates\n  bsr candidate-rp $ip_address priority 200\n  !\n  # for BSR candidates\n  bsr candidate-bsr $ip_address priority 100\n  interface Gi0/0/0/1\n    # stops bsr packets on inter-domain border\n    bsr-border\n  !\n!\n</code></pre> <p>There is no specific configuration required on all other routers, except enabling of multicast globally and on the respective interfaces. Since BSR messages are normal PIM messages, a router will interpret them on any multicast enabled interface.</p> <p><code>show pim bsr election</code> -- list of candidate BSRs <code>show pim bsr rp-cache</code> -- all available RPs</p> <p></p>"},{"location":"Multicast/#anycast-rp","title":"Anycast RP","text":"<p>RP's can be anycasted with Multicast Source Discovery Protocol (MSDP) to provide RP redundancy, rapid RP failover, and RP load balancing. This concept is defined in RFC 3446.</p> <p>MSDP maintains sources state between anycasted RP's. Therefore, MSDP is required to do source active announcements between RPs. This way both RPs know mutually the sources on the other RP and can construct a joint MDT. </p> IOS XE<pre><code>!\ninterface Loopback0\n  ip add 10.0.0.1 255.255.255.255\n!\ninterface Loopback1\n  ip add 10.1.1.1 255.255.255.255\n!\nip msdp peer 10.0.0.2 connect-source Loopback0\nip msdp originator-id Loopback0\nip pim rp-address 10.1.1.1\n</code></pre> IOS XR<pre><code>interface Loopback0\n  ip add 10.0.0.2 255.255.255.255\ninterface Loopback1\n  ip add 10.1.1.1 255.255.255.255\n!\nrouter msdp\n  peer 10.0.0.1 connect-source Loopback0\n  originator-id Loopback0\nrouter pim address-family ipv4\n  rp-address 10.1.1.1\n!\n</code></pre>"},{"location":"OSPF/","title":"OSPF","text":""},{"location":"OSPF/#ospf-multiarea-overview","title":"OSPF Multiarea Overview","text":"<p>There are two types of areas within the area hierarchy of OSPF:</p> <p>Backbone area, transit area, or Area 0: the central entity through which all areas must connect through to exchange routing updates. Usually end users are not connected to this.</p> <p>Regular area: a.k.a. nonbackbone area. It will accept link updates, route summarizations, and external routes. Usually these are set up according to administrative or geographical groupings. </p>"},{"location":"OSPF/#multiarea-advantages","title":"Multiarea advantages","text":"<ul> <li>Minimizes routing table</li> <li>Localizes impact of topology changes (link flap)</li> <li>Detailed LSA flooding stops at area boundaries</li> </ul>"},{"location":"OSPF/#considerations","title":"Considerations","text":"<ul> <li>Potential less optimal forwarding due to loss of granular routing info, maybe.</li> <li>HA should be addressed at area border routes</li> <li>MPLS TE benefits from single area to ensure it can always pick best path</li> </ul>"},{"location":"OSPF/#requirements-for-multiarea","title":"Requirements for multiarea","text":"<ul> <li>Area 0 is backbone, and all other areas must connect to it </li> <li>All areas must be contiguous</li> </ul>"},{"location":"OSPF/#guidelines","title":"Guidelines","text":"Single Area Multiple Areas Provides optimal routing Only use in large environments (100+ routers) Simple implementation and maintenance Use regular areas if possible Best suited for MPLS TE Use stub and NSSA in case of old, CPU-hungry and/or memory-hungry routers -- Ensure HA ABR's -- Focus on addressing plan to enable effective summarization"},{"location":"OSPF/#ospf-area-and-lsa-types","title":"OSPF Area and LSA Types","text":""},{"location":"OSPF/#area-types","title":"Area types","text":"<ul> <li>Backbone area 0 </li> <li>Regular area</li> <li>Stub area: does not accept route info that are external to the AS, such as non-OSPF sources redistributed. They use a default route to route outside the area. It cannot contain an ASBR unless the ABR is also a ASBR. </li> <li>Totally Stubby: does not accept external or summary routes from other areas. They use a default route to route outside the area. It cannot contain ASBR unless the ABR is also a ASBR.</li> <li>NSSA: Similiar to stub area, except it allows for ASBR and uses special type 7 LSA for external routes inside NSSA area.</li> <li>Totally NSSA: Similiar to totally stubby, in that it does not accept external AS routes or summary routes, but it can contain ASBR and external LSA type 7 routes. Cisco proprietary.</li> </ul>"},{"location":"OSPF/#lsa-types","title":"LSA types","text":"<ul> <li>LSA Type 1 - Router LSA -- These exchange info about nodes within an area, and they do not leave the area. They are used to describe the state of router links.<ul> <li>In OSPFv3, router LSA's contain no address info. Instead, there is a new link LSA Type 8 that provides link-local and other addresses on a link for OSPFv3.</li> </ul> </li> <li>LSA Type 2 - Network LSA -- Exchange info about multiaccess links within area, and they never leave the area. DR's generate these. Only flooded in the area that which they belong too.<ul> <li>In OSPFv3, network LSA's contain no address info. The new type 9 LSA intra-area-prefix LSA has route info.</li> </ul> </li> <li>LSA Type 3 - Summary LSA -- ABR's generate summary LSA's based on type 1/2 LSA's, which are flooded into the backbone area to other ABR's. <ul> <li>These are not flooded into totally stubby or totally NSSA areas.</li> </ul> </li> <li>LSA Type 4 - Summary ASBR LSA -- ABR's generate summary advertisements that describe routes to ASBR's. The ASBR floods type 1's, which are converted to Type 4 by ABR's into backbone.<ul> <li>These are not flooded into totally stubby or totally NSSA areas.</li> </ul> </li> <li>LSA Type 5 - External LSA -- ASBR generates AS external link advertisements. They describe routes to destinations external to the OSPF AS and are flooded only into backbone and regular areas (none of the stubs).</li> <li>LSA Type 7 - NSSA LSA -- used by NSSA areas for external routes. These are converted by ABR's into Type 5 when flooding into backbone.</li> </ul>"},{"location":"OSPF/#ospfv2-path-selection","title":"OSPFv2 Path Selection","text":""},{"location":"OSPF/#overview","title":"Overview","text":"<ul> <li>OSPF path selection uses link costs as a metric and the Dijkstra algorithm to build the SPT based on lowest total costs</li> <li>Each link has an assigned cost, then that link is placed at the top of the tree, then the sum cost of links to the destination is calculated.  </li> </ul>"},{"location":"OSPF/#ospf-metric","title":"OSPF Metric","text":"<ul> <li>By default, this is proportional to the bw of the link, but this is out of date given that Gigabit 1Gbps = cost 1. </li> <li>General guidance is to set reference bw to higher value, like 400Gbps  both IOS XE and XR<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-router)# auto-cost reference-bandwidth 400000\n\n# bw in Mbps // 400000 == 400Gbps\n</code></pre></li> <li>You can manually configure cost too IOS XE<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-router)# ip ospf cost 4000\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-ospf)# area 0\nrouter(config-ospf-ar)# int Gi0/0/0/1\nrouter(config-ospf-ar-if)# cost 4000\n</code></pre></li> </ul>"},{"location":"OSPF/#path-selection-criteria","title":"Path Selection Criteria","text":"<ul> <li>It is important to remember cost is not the most preferred</li> <li>Select the path based on LSA preference<ol> <li>Intra Area</li> <li>Inter Area</li> <li>External Type 1</li> <li>NSSA Type 1 </li> <li>External Type 2</li> <li>NSSA Type 2</li> </ol> </li> <li>Then if there are multiple paths of the same type, evaluate one with the lowest cost</li> </ul>"},{"location":"OSPF/#ospfv2-summarization","title":"OSPFv2 Summarization","text":"<ul> <li>Summarization is the key to scaling OSPF. It saves you from a large routing table and frequent flooding throughout the backbone due to potential link flaps. A summary route can hold down (aka not flap) more specific prefixes inside the summary. </li> <li>An ABR will automatically translate the Type 1 and Type 2 LSA's into their individual Type 3 Summary LSA's, and when enabled, they can summarize these into consolidated Type 3's. </li> <li>A good addressing plan that lends itself to aggregation at the OSPF area borders is key!</li> </ul>"},{"location":"OSPF/#ospf-interarea-route-summarization","title":"OSPF Interarea Route Summarization","text":"<ul> <li>Only ABR's can summarize. Use <code>area 1 range</code> on IOS XE and <code>range</code> on IOS XR.</li> <li>Summary cost is equal to the minimum cost of a summarized prefix (RFC1583, default), or if enabled, the maximum cost based on RFC2328. <code>no compatible rfc1583</code></li> <li>The ABR will generate a Null0 route for loopback protection</li> </ul>"},{"location":"OSPF/#configuration-example-on-abr-between-area-0-and-area-1","title":"Configuration example on ABR between Area 0 and Area 1","text":"<p>IOS XE<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-router)# area 1 range 192.168.0.0 255.255.0.0\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-ospf)# area 1\nrouter(config-ospf-ar)# range 192.168.0.0/16\n</code></pre></p>"},{"location":"OSPF/#ospf-external-route-summarization","title":"OSPF External Route Summarization","text":"<ul> <li>Summarization of external routes can be done on the ASBR for type 5 LSAs (redistributed routes) before injecting them into the OSPF domain. Use <code>summary-address</code> on IOS XE and <code>summary-prefix</code> on IOS XR.</li> <li><code>not-advertise</code> will filter out longer-prefixes within summary</li> <li>For NSSA areas, the ABR can summarize the Type 7 LSA's and associated external routes</li> <li>NOTE -- when redistributing on an ASBR, the imported prefixes will use subtype 2 (E2) by default. These have a \"frozen\" cost that will not increment cost based on link path when doing SPT. E1 subtype can be used for original external cost + total internal metric (per normal).</li> </ul>"},{"location":"OSPF/#configuration-example-for-external-route-summarization","title":"Configuration example for External Route Summarization","text":"<ul> <li>This is on the ASBR at the external AS boundary where redistribution happens IOS XE<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-router)# summary-address 10.10.0.0 255.255.0.0 not-advertise\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-ospf)# area 1\nrouter(config-ospf-ar)# summary-prefix 10.10.0.0 255.255.0.0\n</code></pre></li> </ul>"},{"location":"OSPF/#ospf-special-areas","title":"OSPF Special Areas","text":"<ul> <li>Overall purpose is to inject a default route to reduce number of LSA's flooded into special area</li> <li>Stub areas are designed to reduce the amount of flooding, the LSDB size, and the routing table size in routers within the area</li> <li>They improve performance in OSPF networks and improve scalability</li> </ul>"},{"location":"OSPF/#ospf-stubby-area","title":"OSPF Stubby Area","text":"<ul> <li>Do not accept LSA's that are external to the AS, such as Type 5 LSA</li> <li>The Type 3 LSA allowed, and a default route injected as a Type 3. By default, the default route cost is 1. <code>area default-cost</code> to modify this. </li> <li>ALL routers in the stub area must be configured with <code>stub</code> configuration, including the ABR</li> </ul>"},{"location":"OSPF/#configuration-examples-stubby-area","title":"Configuration Examples - Stubby Area","text":"<p>IOS XE<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-router)# area 2 stub\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-ospf)# area 2\nrouter(config-ospf-ar)# stub\n</code></pre></p>"},{"location":"OSPF/#ospf-totally-stubby-area","title":"OSPF Totally Stubby Area","text":"<ul> <li>Same as Stub area + filters ALL Type 3 LSA's. The only Type 3 allowed is the injected default route by ABR. </li> <li>Cisco proprietary enhancement to further reduce the number of routes and LSA's</li> <li>Using totally stubby areas is typically a better solution than using stub areas</li> </ul>"},{"location":"OSPF/#configuration-examples-totally-stubby-area","title":"Configuration Examples - Totally Stubby Area","text":"<ul> <li>Uses the addition of <code>no-summary</code> on area stub commands</li> </ul> <p>IOS XE<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-router)# area 2 stub no-summary\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-ospf)# area 2\nrouter(config-ospf-ar)# stub no-summary\n</code></pre></p>"},{"location":"OSPF/#ospf-nssa","title":"OSPF NSSA","text":"<ul> <li>Same as a stub area, so Type 3 LSA's are allowed + a Type 3 with default route injected by ABR</li> <li>Defines a special type 7 LSA to allow for ASBR in a stub area for route redistribution</li> <li>At the ABR, the type 7 LSA is converted into a type 5 LSA</li> <li>In the case that the ABR is also the ASBR, type 7 LSAs NOT have the propagate-bit (P-bit) in the LSA header to prevent propagation loops between the NSSA and the backbone area. If the ASBR is not the ABR, the the P-bit will be set, and the ABR will know to convert to Type 5 and flood into backbone area.</li> <li>If there are multiple ABR's in NSSA, only the ABR with the highest Router ID will translate these Type 7's with P-bit</li> <li>In the routing table, Type 7 LSA's are shown as <code>O N2</code> by default, or if desired, they can be <code>O N1</code> like external type 1 with calculated total cost. </li> </ul>"},{"location":"OSPF/#configuration-examples-nssa","title":"Configuration Examples - NSSA","text":"<p>IOS XE<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-router)# area 2 nssa\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-ospf)# area 2\nrouter(config-ospf-ar)# nssa\n</code></pre></p>"},{"location":"OSPF/#ospf-totally-nssa","title":"OSPF Totally NSSA","text":"<ul> <li>Same as NSSA combined with Totally Stubby to filter out Type 3 LSA's</li> <li>Cisco proprietary enhancement IOS XE<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-router)# area 2 nssa no-summary\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-ospf)# area 2\nrouter(config-ospf-ar)# nssa no-summary\n</code></pre></li> </ul>"},{"location":"OSPF/#ospf-area-design-guidelines","title":"OSPF Area Design Guidelines","text":"<ul> <li>Use a single area if possible</li> <li>Use regular areas if needed for scalability</li> </ul>"},{"location":"OSPF/#ospfv2-virtual-links","title":"OSPFv2 Virtual Links","text":"<ul> <li>Used in rare scenarios where an area is introduced that cannot have direct physical or logical access to the backbone area 0.<ul> <li>I.E. - M&amp;A's or combining previous segmented networks</li> </ul> </li> </ul>"},{"location":"OSPF/#virtual-link-use-cases","title":"Virtual Link Use Cases","text":"<ul> <li>VL can be used to connect discontiguous backbone area 0's, and it can be used to connect another regular or stub area through a nonbackbone area to the backbone area 0.</li> <li>Relies on intra-area routing and stability of the underlying area. If you are connecting two area 0's together via a regular area that has poor stability, it could be a bad time.</li> </ul>"},{"location":"OSPF/#virtual-link-characteristics","title":"Virtual Link Characteristics","text":"<ul> <li>the virtual link cost = total cost in path to destination</li> <li>serves as an extension of the backbone area 0</li> <li>cannot traverse stubby or NSSA areas!!</li> <li>also cannot traverse unnumbered links (?)</li> <li>the virtual link is treated as a direct connection between the ABR's of connected areas. Ideally you would use loopback interfaces as router ID to source the connectivity for the virtual links.</li> </ul>"},{"location":"OSPF/#configuration-examples-virtual-links","title":"Configuration Examples - Virtual Links","text":"<p>IOS XE<pre><code>router-abr2# conf t\nrouter-abr2(config)# router ospf 1\nrouter-abr2(config-router)# area 2 virtual-link 10.1.1.55\n</code></pre> IOS XR<pre><code>router-abr55# conf t\nrouter-abr55(config)# router ospf 1\nrouter-abr55(config-ospf)# area 2\nrouter-abr55(config-ospf-ar)# virtual-link 10.1.1.2\n</code></pre></p>"},{"location":"OSPF/#virtual-link-guidelines","title":"Virtual Link Guidelines","text":"<ul> <li>Do not use these as a primary design tool</li> <li>A valid virtual link use case is where there is one physical link between two ABRs in the same area, and the link should be available to the backbone area and nonbackbone area.</li> </ul>"},{"location":"OSPF/#ospf-fast-convergence","title":"OSPF Fast Convergence","text":"<ul> <li>By default, OSPF can take up to 40 seconds to converge upon a link or device failure.<ul> <li>Default hello timer = 10 seconds</li> <li>Default dead timer = 40 seconds</li> </ul> </li> <li>Cisco (and standards-based) techniques to improve convergence and OSPF stability:<ul> <li>Tune OSPF timers (hello/dead intervals, SPF, LSA)</li> <li>Cisco Nonstop Forwarding (NSF)</li> <li>Cisco Nonstop Routing (NSR)</li> <li>Bidirectional Forwarding Detection (BFD) for OSPF</li> </ul> </li> </ul>"},{"location":"OSPF/#tuning-ospf-timers","title":"Tuning OSPF Timers","text":"<ul> <li>Lower timers can result in quicker detection and convergence time</li> <li>Configured at interface levels (and they must match to ensure stable adjacency between neighbors) IOS XE<pre><code>router# conf t\nrouter(config)# interface gi1/2\nrouter(config-if)# ip ospf hello-interval 5\nrouter(config-if)# ip ospf dead-interval 15\n# OR another dead-interval style conf\nrouter(config-if)# ip ospf dead-interval minimal hello-multiplier 3\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-ospf)# area 2\nrouter(config-ospf-ar)# interface gi0/0/1/5\nrouter(config-ospf-ar-if)# hello-interval 5\nrouter(config-ospf-ar-if)# dead-interval 15\n</code></pre></li> </ul>"},{"location":"OSPF/#cisco-nsf-and-nsr","title":"Cisco NSF and NSR","text":"<ul> <li>Cisco NSF and Cisco NSR are two techniques that can provide stability to routing during route processor (RP) failures, restarts, switchovers, process restarts, and similar events in which the routing tables would be flushed due to loss of OSPF process.</li> <li>NSF allows data plane to continue forwarding during RP failover while the standby RP re-establishes OSPF database and state.</li> <li>Upon a RP failure, the NSF-capable router sends an OSPF Cisco NSF signal to neighboring NSF-aware devices to not reset adjacency in the form of a link-local LSA (type 8?). The NSF-cabable (failed over device) rebuilds neighbor list based on this LSA and response.</li> <li> <p>It rebuilds neighbor list and then resyncs the LSDB with all NSF-aware neighbors to remove stale entries and update RIB and FIB. </p> </li> <li> <p>Cisco NSR allows RP failures, process restarts, and in-service upgrades to be invisible to peers. If available, makes it easier to utilize NSF and IETF graceful restart protocol extensions</p> </li> </ul>"},{"location":"OSPF/#bidirectional-forwarding-detection-bfd","title":"Bidirectional Forwarding Detection (BFD)","text":"<ul> <li>BFD provides a low-overhead, short-duration method of detecting failures in the forwarding path between two adjacent routers, including the interfaces, data links, and forwarding planes</li> <li>Async mode is supported, so after it is configured, a session is created, timers are negotiated, and peers send BFD control plane packets at negotiated interval.</li> <li>No neighbor discovery process-- configured on both sides.</li> <li>BFD relies on control packets or echo packets<ul> <li>They are IP packets addressed to the sending router itself but forwarded to the L2 address of the next-hop node. When the neighboring router receives this packet, it performs a L3 lookup (based on IP dst address) and sends the packet back to the final destination (the originating router)</li> </ul> </li> </ul>"},{"location":"OSPF/#configuring-bfd-for-ospf","title":"Configuring BFD for OSPF","text":"<p>IOS XE<pre><code>router# conf t\nrouter(config)# interface gi1/2\nrouter(config-if)# bfd interval 50 min_rx 50 multiplier 5\nrouter(config-if)# ip ospf bfd\n# OR \nrouter(config-if)# bfd all-interfaces\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-ospf)# bfd minimum-interval 50\nrouter(config-ospf)# bfd multiplier 5\nrouter(config-ospf)# area 1\nrouter(config-ospf-ar)# interface gi0/0/1/5\nrouter(config-ospf-ar-if)# bfd fast-detect\n</code></pre></p>"},{"location":"OSPF/#ospf-for-ipv6","title":"OSPF for IPv6","text":"<ul> <li>OSPFv3 is a multiprotocol implementation of OSPF that supports IPv6 in addition to IPv4</li> <li>Router-id is no longer based on IPv4 address, it is configured in the routing process and is still a 32-bit number that is used to sign routing updates</li> <li>OSPFv3 adfancies and next-hop attributes use link-local addresses</li> <li>IPv6 is used to transport LSA's</li> <li>Only enabled per-link, not per-network</li> <li>Router ID, area ID, and link-state ID remain 32 bits (not from an IPv4 address)</li> <li>LSA's have a flooding scope based on a radius:<ul> <li>link-local</li> <li>area</li> <li>AS</li> <li>handling and forwarding of unknown LSA's is supported</li> </ul> </li> <li>Uses link-local multicast addresses:<ul> <li>FF02::5 for OSPF routers</li> <li>FF02::6 for OSPF DR's</li> </ul> </li> </ul>"},{"location":"OSPF/#different-or-renamed-lsas","title":"Different or renamed LSA's","text":"<p>Interarea-prefix LSA for ABRs (Type 3) -- advertises internal networks to routers in other areas. Prefix length is used instead of subnet mask. Default route is a /0 prefix length.</p> <p>Interarea LSA for ASBR (Type 4) -- advertses the location of an ASBR. Routers trying to reach an external network use these to determine the best path to the next hop. ABR's generate these on behalf of ASBR.</p>"},{"location":"OSPF/#new-lsas","title":"New LSA's","text":"<p>Link LSA (Type 8) -- (replaces Type 1) Link-local flooding scope. They are not flooded beyond the link with which they are associated. They provide a link-local address of router to all other routers on the link, informing others attached on that local link of prefixes associated with the link, and also allows the originating router to asset a collection of option bits with that network LSA that will be originated for the link.</p> <p>Intra-area-prefix LSA (Type 9) -- (replaces Type 2) a router can originate LSA type 9's for each router or transit network with unique link-state ID's. The link-state ID describes its association to either a router or network LSA and contains prefixes for stub or transit networks.</p>"},{"location":"OSPF/#configuring-ospfv3","title":"Configuring OSPFv3","text":"<ul> <li>A routing process is not explicitly required, just enable an interface and it will cause a routing process to be created.</li> </ul> <p>IOS XE<pre><code># IPv6 addressing is implied\nrouter# conf t\nrouter(config)# interface gi1/2\nrouter(config-if)# ipv6 ospf 1 area 0\nrouter(config)# ipv6 router ospf 1\nrouter(config-router)# area 2 range 2001:db9:1::/48\n</code></pre> IOS XR<pre><code>router# conf t\nrouter(config)# router ospfv3 1\nrouter(config-ospf)# area 0 \nrouter(config-ospf-ar)# int gi0/0/1/5\n</code></pre></p> <ul> <li>For IOS XR, both inter-area route summarization uses the <code>range</code> config, and <code>summary-prefix</code> for external route summarization on ASBR (upon redistribution into OSPF from external AS)</li> </ul>"},{"location":"OSPF/#troubleshooting-ospf","title":"Troubleshooting OSPF","text":"<ul> <li>Understanding the requirements and limitations of OSPF is critical to troubleshooting</li> <li>OSPF neighborships/adjacency requires these to align:<ul> <li>area id: the areas configured on interfaces</li> <li>hello and dead intervals: must/should match. If not, then possibly if no hellos within the dead interval, then neighbor is declared dead</li> <li>subnet mask: must match; although not requirement for p2p links</li> <li>authentication key: must match, if not there is no adjacency</li> <li>network type: p2p or other, must match so DR/BDR election can take place</li> <li>stub flag: routers must use the same flag</li> <li>MTU: LSA's can or will be dropped if there is a mismatch </li> </ul> </li> </ul>"},{"location":"OSPF/#troubleshooting-incomplete-ospf-adjacency","title":"Troubleshooting Incomplete OSPF Adjacency","text":"<ul> <li>Final OSPF state is Full after routing tables are synced.</li> <li>Cisco.com OSPF Neighbor States</li> <li>On a multiaccess network, a router will stay in 2-way state with non-DR/BDR neighbors</li> </ul> <p>Common Issues in each state:</p> <ul> <li>DOWN state or there is no state<ul> <li>OSPF process has not received any hellos packets from neighbor</li> <li>Things to look at:<ol> <li>Check cabling, check ACL's or firewalls to verify forwarding and tx/rx between neighbors</li> <li>Verify OSPF is enabled -- <code>show ip ospf int</code></li> <li>Verify that OSPF is not passive on interface</li> <li>Check that the router ID is different on both sides</li> <li>Validate the required parameters</li> </ol> </li> </ul> </li> <li>INIT State<ul> <li>Router has received a hello packet from neighbor, but it does not yet see its own router ID in the hello packet from neighbor</li> <li>Things to look at:<ol> <li>Verify ACL's or firewalls to verify forwarding and tx/rx between neighbors</li> <li>Check there are no layer 2 problems between neighbors</li> <li>Verify authentication matches on both sides if using</li> </ol> </li> </ul> </li> <li>EXSTART, Exchange<ul> <li>The Database Description (DBD) and LSA packet exchange were not successful after DR, BDR election</li> <li>Check MTU or if NAT is being used to translate OSPF packets</li> <li>Check for possible interoperability issues if neighbor is another vendor </li> <li>Verify the router ID's are different</li> </ul> </li> </ul>"},{"location":"OSPF/#ospf-route-exchange-troubleshooting-between-areas","title":"OSPF Route Exchange Troubleshooting between Areas","text":"<ul> <li>If there is a discontiguous area 0 or another area is seperated from area 0, then there will be route exchange issues since all areas rely on area 0 to exchange routing information</li> <li>If there is inconsistent routing, validate that:<ul> <li>OSPF interfaces are in the correct and intended area</li> <li>Check ABR's - <code>show ospf border-routers</code></li> <li>Validate there is no route-map or route-policy filtering inbound routes</li> </ul> </li> </ul>"},{"location":"Route%20Redistribution/","title":"Route Redistribution","text":"<p>Routing redistribution can be used when there is more than one routing protocol used in an AS, and to achieve end-to-end reachability, you can use redistribution to exchange full routing info.</p> <p>Often, the transition between routing protocols as the environment grows is not fast. 2 or more routing protocols may exist for a long time. </p> <p>Different protocols have different requirements and limitations when redistributing, so it is important to be aware of these and configure them carefully.</p> <p>The main design considerations:</p> <ul> <li>One or two way redistribution?</li> <li>One or multiple redistribution points?</li> <li>Impact of external routes on a routing protocol</li> </ul>"},{"location":"Route%20Redistribution/#the-need-for-redistribution","title":"The Need for Redistribution","text":"<p>Over time, a network becomes more complex as different network groups adjust it based on factors such as political borders, geographical borders, and m&amp;a.</p> <p>Routing challenges stemming from differences in the environment:</p> <ul> <li>different devices/vendors</li> <li>branches, hubs, core networks, PoP design</li> <li>Different regions/countries</li> <li>Multiple separate companies</li> <li>M&amp;A causing different entities to smash together</li> </ul> <p>Multiple routing protocols can exist in some example scenarios:</p> <ul> <li>When migrating from older IGP to new IGP, multiple redistribution boundaries may exist until new IGP completely displaces the old one. Similiarly, this applies for mergers between companies.</li> <li>Depending on company, some departments may not upgrade their routers to support new protocols etc</li> <li>Mixed vendor environments. EIGRP on Cisco, OSPF on others.</li> <li>Modern SP environments may also have colocation, cloud networks where a different set of devices and technology exists</li> </ul>"},{"location":"Route%20Redistribution/#route-redistribution-characteristics","title":"Route Redistribution Characteristics","text":"<p>Tthe process of using a routing protocol to advertise routes that are learned by the usual means of learning routes, such as by another routing protocol, static routes, or directly connected routes.</p> <ul> <li>Possible redistribution sources:<ul> <li>Other routing protocols, static routes, connected routes</li> </ul> </li> <li>Internal loop prevention mechanisms<ul> <li>Only routes that are actually in the routing table will be redistributed</li> </ul> </li> </ul>"},{"location":"Route%20Redistribution/#route-redistribution-seed-metrics","title":"Route Redistribution Seed Metrics","text":"<ul> <li>The seed metric or redistributed metric is the starting cost for routes that are redistributed from other protocols. </li> <li>Each protocol behaves differently, some vary depending on protocols</li> </ul> <p>RIP and EIGRP will not redistribute unless you configure a metric (seed it). It will be 0 by default, which is infinity hops, which is unreachable.</p> <p>For IS-IS, the metric of 0 will be the lowest cost, while in OSPF, it will be 20 (E2).</p> <p>For BGP, it will copy the originating routing protocols metric as the MED attribute value (metric), which is then propagated throughout.</p>"},{"location":"Route%20Redistribution/#redistribution-strategies","title":"Redistribution strategies","text":"<p>Redistribution can bring with it many challenges, and you should approach it carefully to not cause additional issues when trying to solve business needs. Routing across your org should be stable and efficient.</p> <p>Some of these challenges:</p> <ul> <li>Suboptimal routing</li> <li>Inconsistent convergence timers</li> <li>Routing update loops: loop prevent methods do not span protocols (such as iBGP split horizon)</li> <li>Route flapping: redistributed routes can preempt each other</li> <li>Intermittent routing loops: then when there is route flaps, possibility for loops</li> </ul>"},{"location":"Route%20Redistribution/#one-point-route-redistribution","title":"One-Point Route Redistribution","text":"<ul> <li>Route redistribution is only done at one point in the network, and it can either be one-way or two-way<ul> <li>If there is one-way, then there should be a default or static route for the other routing protocl to ensure two-way comms</li> </ul> </li> <li>The advantage of one-point is that there is no risk of routing loops</li> </ul>"},{"location":"Route%20Redistribution/#multipoint-route-redistribution","title":"Multipoint Route Redistribution","text":"<ul> <li>Same as earlier, except in multiple places and options for both one-way and two-way</li> <li>If the receiving routing protocol supports different administrative distances for internal and external routes, it can work better<ul> <li>Another common method is to tag routes reditributed from one routing protocol to another, then use route-maps or RPL to prevent re-redistribution of routes at the other redistribution points</li> </ul> </li> </ul>"},{"location":"Route%20Redistribution/#solutions-to-route-distributions","title":"Solutions to route distributions","text":"<ul> <li>Manipulate routing metrics or administrative distance</li> <li>Filter redistributed routes to ensure only what you want is being redistributed</li> <li>Use tags to simplify identification of redistributed routes</li> <li>Summarize redistributed routes when possible</li> <li> <p>Consider using a default route to stick with one-way redistribution</p> </li> <li> <p>Be wary of administrative distance when doing redistribution</p> <ul> <li>For example, if you have a connected route, and you redistribute this on R1 into EIGRP. This will be an EIGRP-external route with 170 AD, but if this is redistributed into OSPF, it will be 110 AD. Possibly this could result in suboptimal routing depending on where the routing decisions are made on the network.</li> </ul> </li> </ul>"},{"location":"Route%20Redistribution/#configuring-route-redistribution","title":"Configuring Route Redistribution","text":"<ul> <li><code>redistribute</code> command is entered under the importing routing protocol</li> <li> <p>You mainly will be concerned with:</p> <ul> <li>Source routing protocol (and maybe process)</li> <li>Protocol-specific filters</li> <li>Setting of a default metric</li> <li>Tagging redistributed routes</li> <li>Filtering and modifying routes via <code>route-maps</code> and <code>route-policy</code></li> </ul> </li> </ul>"},{"location":"Route%20Redistribution/#ospf-redistribution","title":"OSPF Redistribution","text":"<ul> <li>Use the <code>subnet</code>s` option to ensure all routes are redistributed</li> <li>Use the <code>metric-type 1</code> option to ensure LSA type 5 External type 1 is used so that the cost will be updated and considered throughout the OSPF domain, otherwise link costs will never be appended when propogating the route across the network</li> </ul> IOS XE<pre><code>router# conf t\nrouter(config)# router ospf 1\nrouter(config-router)# redistribute eigrp 1 subnets metric-type 1 metric 100000 tag 100\n</code></pre> IOS XR<pre><code>RP/0/RP0/CPU0:router# conf t\nRP/0/RP0/CPU0:router(config)# router ospf 1\nRP/0/RP0/CPU0:router(config-ospf)# redistribute eigrp 1 subnets metric-type 1 metric 100000 tag 101\n</code></pre>"},{"location":"Route%20Redistribution/#redistribution-into-is-is","title":"Redistribution into IS-IS","text":"IOS XE<pre><code>router# conf t\nrouter(config)# router isis 1\nrouter(config-router)# redistribute connected metric 1000 route-map ISIS-Redistribute-Conn\n</code></pre> IOS XR<pre><code>RP/0/RP0/CPU0:router# conf t\nRP/0/RP0/CPU0:router(config)# router isis 1\nRP/0/RP0/CPU0:router(config-isis)# address-family ipv4 unicast\nRP/0/RP0/CPU0:router(config-isis-af)# redistribute connected metric 1000 route-policy ISIS-Redistribute-Conn\n</code></pre>"},{"location":"Route%20Redistribution/#redistribution-into-bgp","title":"Redistribution into BGP","text":"<ul> <li>Basically... the exact same</li> </ul> IOS XE<pre><code>router# conf t\nrouter(config)# router bgp 65001\nrouter(config-router)# redistribute ospf 1 match internal route-map BGP-Redistribute-OSPF\n</code></pre> IOS XR<pre><code>RP/0/RP0/CPU0:router# conf t\nRP/0/RP0/CPU0:router(config)# router bgp 65002\nRP/0/RP0/CPU0:router(config-bgp)# address-family ipv4 unicast\nRP/0/RP0/CPU0:router(config-bgp-af)# redistribute ospf 1 match internal route-policy BGP-Redistribute-OSPF\n</code></pre>"},{"location":"Route%20Redistribution/#administrative-distance","title":"Administrative Distance","text":"Routing Protocol Default AD Connected Route 0 Static Route 1 EIGRP summary route 5 EBGP 20 Internal EIGRP 90 OSPF 110 IS-IS 115 RIP 120 External EIGRP 170 iBGP 200 <p>Modifying OSPF AD</p> <ul> <li>Default is 110, and you can modify this with global OSPF command <code>distance</code>, or with <code>distance ospf external xx inter-area yy intra-area zz</code> to modify the external, inter-area, and intra-area routes more specifically. </li> <li>The command is the same on IOS-XE and IOS-XR</li> <li>More selective AD can help with multi-point multi-way redistribution</li> </ul> <p>Modifying IS-IS AD</p> <ul> <li>Default is 115, and this is mod'd with <code>distance</code> in global <code>router isis</code> mode on IOS-XE and for IOS-XR, under the <code>address-family ipv4 unicast</code> config mode.</li> </ul> <p>Modifying BGP AD</p> <ul> <li>Default is 20 for EBGP routes, 200 for iBGP routes</li> <li> <p>Use the command <code>distance bgp $external $internal $local_routes</code>, like <code>distance bgp 20 80 80</code> under global router bgp mode in both IOS-XE/XR </p> </li> <li> <p>Great care should be taken to not advertise BGP next-hops through BGP, which would cause BGP neighborships to flap!</p> </li> </ul>"},{"location":"Route%20Redistribution/#routing-loop-prevention-strategies","title":"Routing Loop Prevention Strategies","text":"<p>If you do not take any precautions when doing two-way multi-point redistribution, then there will be a routing loop.</p> <ol> <li>Tag redistributed routes</li> <li>Then filter out tagged routes upon redistribution</li> </ol> <p>Let's look at an example with BGP and OSPF two-way multi-point redistribution.</p> <p>On the two routers, we have BGP and OSPF. We'll create a route-map to deny routes with matching BGP community 10, then set tag 10 on routes redistributed into OSPF from BGP.</p> IOS XE<pre><code>router# conf t\nrouter(config)# ip community-list 10 permit 65001:10\nrouter(config)# route-map FilterAndTagBGP deny 10\nrouter(config-router-map)# match community 10\nrouter(config-router-map)# exit\nrouter(config)# route-map FilterAndTagBGP permit 100\nrouter(config-router-map)# set tag 10\nrouter(config-router-map)# exit\nrouter(config)# router ospf 1\nrouter(config-router)# redistribute bgp 65001 subnets metric-type 1 route-map FilterAndTagBGP\n</code></pre> IOS XR<pre><code>RP/0/RP0/CPU0:router# conf t\nRP/0/RP0/CPU0:router (config-rpl)# route-policy FilterAndTagOSPF\nRP/0/RP0/CPU0:router (config-rpl)# if tag eq 10 then\nRP/0/RP0/CPU0:router (config-rpl)#   drop\nRP/0/RP0/CPU0:router (config-rpl)# else\nRP/0/RP0/CPU0:router (config-rpl)#   set community (65001:10)\nRP/0/RP0/CPU0:router (config-rpl)#   pass\nRP/0/RP0/CPU0:router (config-rpl)# endif\nRP/0/RP0/CPU0:router (config-rpl)# end-policy\nRP/0/RP0/CPU0:router (config)# router bgp 65001\nRP/0/RP0/CPU0:router (config-bgp)# address-family ipv4 unicast\nRP/0/RP0/CPU0:router (config-bgp-af)# redistribute ospf 1 route-policy FilterAndTagOSPF\n</code></pre>"},{"location":"Routing%20Policy/","title":"Routing Policy and Manipulation","text":""},{"location":"Routing%20Policy/#routing-protocol-tools","title":"Routing Protocol Tools","text":"<p>For security and performance reasons, you will always use advanced filtering and policy mechanisms with BGP.</p> <p>Filtering can be performed at these points:</p> <ul> <li>Incoming updates as they are received from neighbors but before they are installed into protocol and RIB</li> <li>Outgoing updates before they are sent to neighbor</li> <li>Redistributed updates from other protocols</li> </ul> <p>You filter routing info based on:</p> <ul> <li>Prefix and prefix length</li> <li>Then update parameters (attributes) that are specific to that protocol</li> </ul> <p>Then filtering uses these tools in routing software:</p> <ul> <li>Prefix lists:<ul> <li>Used for prefix-based filtering or route matching</li> </ul> </li> <li>AS path access lists:<ul> <li>Used in BGP for filtering or route matching based on BGP AS path attribute</li> </ul> </li> <li>Route maps:<ul> <li>Implements complex routing policies</li> <li>Can also be used to filter </li> </ul> </li> <li>RPL (Route Policy Language):<ul> <li>Replaces route maps on IOS XR, more complex feature rich language</li> </ul> </li> </ul>"},{"location":"Routing%20Policy/#filtering-examples","title":"Filtering Examples","text":"<p>So at a high level, we implement filtering because of:</p> <ol> <li>Security</li> <li>Cost</li> <li>Performance</li> </ol> <p>And then filter:</p> <ul> <li>Particular Routes</li> <li>Specific characteristics of the routes</li> </ul> <p>Different protocols perform filtering very differently... </p>"},{"location":"Routing%20Policy/#filtering-in-ospf","title":"Filtering in OSPF:","text":"<ul> <li>Prefix and prefix length</li> <li>LSA type (internal, external, NSSA-external)</li> <li>route source</li> </ul> <p>Done on ABR or ASBR's</p> <p>Filtering on ASBR for redistributed routes:</p> <ul> <li>Static and connected routes</li> <li>Routes from other OSP processes</li> <li>Routes from other routing protocols</li> </ul> <p>Filter on ABR against interarea routes using prefix lists on which routes can be shared between areas.</p>"},{"location":"Routing%20Policy/#filtering-in-is-is","title":"Filtering in IS-IS:","text":"<p>Similiar characteristics as OSPF. Except you can use prefix lists, route maps, or routing policies to filter an exchange of routing info between IS-IS levels</p> <ul> <li>Filter on Level 1-2 routers<ul> <li>Filter L1 to L2 routes.</li> <li>Conditional L2 to L1 route leaking.</li> </ul> </li> <li>Filtering on redistributing routers (any level) to filter external routes.</li> </ul>"},{"location":"Routing%20Policy/#filtering-in-bgp","title":"Filtering in BGP:","text":"<p>You will almost always/should/must filter in BGP. The type and direction depends on the neighbor (internal, customer, or external).</p> <p>Inbound filtering examples:</p> <ul> <li>permit in only customer routes for end customers</li> <li>permit in a specific list of routes from subordinate SP's, SP's that are peering at an exchange</li> <li>permit the complete inet routing info between upstream service providers</li> </ul> <p>Outbound filtering examples:</p> <ul> <li>permit only the default route with single-homed customers</li> <li>permit default route and local routes, such as for multihomed customers using this service as a backup route but want access to local destinations</li> <li>Permit all routes</li> </ul> <p>Commonly filtered on attributes with BGP:</p> <ul> <li>Prefix and prefix length</li> <li>Next-hop attribute based on BGP next-hop address</li> <li>Route source address</li> <li>AS path attribute</li> <li>Local preference</li> <li>BGP communities </li> </ul> <p>Some of the most commonly implemented policies are:</p> <ul> <li>Customers using AS path prepending to make one path less desirable than another when multihomed</li> <li>Customers can alternatively signal to their upstream providers prefernces using BGP communities. The upstream SP will then translate these communities received to some BGP attribute (like AS path prepending or local preference).</li> <li>SP's can use BGP local preference to influence route selection internally to prefer one path over another</li> </ul>"},{"location":"Routing%20Policy/#as-path-based-filtering","title":"AS Path-based filtering","text":"<p>IOS/XE supports this with AS path access lists. IOS-XR supports similiar filtering with RPL.</p>"},{"location":"Routing%20Policy/#ios-xe-configurations","title":"IOS/-XE Configurations","text":"<p>Uses AS path access lists, then something is done with this.</p> <p>The syntax is:</p> <ul> <li>use a unique number.</li> <li>regex used to match based on the contents of the AS path attribute.</li> <li>AS path attribute processed as a string of characters.</li> </ul> <p><code>ip as-path access-list [acl-number] {permit|deny} [regex string with AS numbers]]</code></p> <p>An example like <code>ip as-path access-list 1 permit ^$</code> matches any route that has an empty AS path attribute. Only locally originated routes have an empty AS path attribute, so this will only send local originated routes. This is one method to prevent accidental transit AS. </p>"},{"location":"Routing%20Policy/#route-maps","title":"Route maps","text":"<p>Route maps are a relatively simple language to support complex policies + filtering</p> <p>Some characteristics:</p> <ul> <li>Allow you to write complex policies</li> <li>Uniquely identified with case-sensitive names</li> <li>Each route map consists of one or more statements</li> <li>Each statement contains zero or more <code>match</code> commands</li> <li>Each statement contains zero or more <code>set</code> commands used to modify routing updates</li> </ul> <p>Route map processing:</p> <ol> <li>Match y/n? </li> <li>If Match, then permit y/n?</li> <li>If permit, then set y/n?</li> <li>If permit yes or no, then send</li> </ol> <p>Route maps have an implicit deny at the end. If there are no matches, then routes are dropped.</p>"},{"location":"Routing%20Policy/#syntax","title":"Syntax","text":"<pre><code>route-map (map-tag) [permit|deny] {sequence number}\n  match (condition)\n  match (condition)\n  set (parameter-value)\n  set (parameter-value)\n</code></pre> <p>If 2 match statements, then they are evaluated as such:</p> <ul> <li>match conditions of same type are evaluated using logical <code>OR</code> operator </li> <li>match condtions of different types are evaluated using logical <code>AND</code> operator</li> </ul> <p>If there is no <code>match</code> command, then it matches anyways.</p> <p>There are additional route map options: - <code>continue</code> to jump to another statement instead of exiting or impled continue if no sequence number specified. (More here)[https://www.cisco.com/c/en/us/td/docs/routers/ios/config/17-x/ip-routing/b-ip-routing/m_irg-route-map-continue.html]     - Useful when gathering policy (matches and sets) into a single phrase or some more logical constructs (can't think of any examples...) - <code>policy-list</code> in match statements, like <code>match policy-list (other-route-map)</code> which has a list of permit lines with matches and other logic</p> <p>To implement a permit all logic, you would do something like: <pre><code>route-map Example_Peering_Ngbh permit 10\n match ip address prefix-list preferred_prefixes\n set local-preference 200\n!\nroute-map Example_Peering_Ngbh permit 1000\n</code></pre></p>"},{"location":"Routing%20Policy/#routing-policy-language","title":"Routing Policy Language","text":"<p>RPL has these characteristics:</p> <ul> <li>Replaces route maps in IOX-XR</li> <li>Designed for large-scale routing configs</li> <li>\"Simple\", powerful language, designed to process routing updates</li> <li>Addresses the deficiencies of route maps...<ul> <li>Better modularity and reusability</li> <li>Parameterization</li> <li>Nesting of policies and conditions</li> <li>Greater matching and reusable value sets</li> </ul> </li> </ul> <p>Has the notion of sets: prefix-sets, community-sets, as-path-sets, extcommunity-sets, and rd-sets that represent groups of IPv4/IPv6 prefixes, etc, route distinguishers values. </p>"},{"location":"Routing%20Policy/#rpl-syntax","title":"RPL Syntax","text":"<p>Each routing policy is defined with a case-sensitive name. The policy is defined within <code>route-policy $name</code> and <code>end-policy</code>. </p> <p>A very simple \"allow all\" policy: <pre><code>route-policy PermitAll\n  pass\nend-policy\n</code></pre></p> <p>There is a process for pass/drop:</p> <ul> <li>default action is drop, so an empty policy implicitly denies all</li> <li>an explicit <code>pass</code> by itself will forward all routes without modification</li> <li>an explicit <code>drop</code> by itself will deny/dropp all, even if there are other statements preceding or other statements in the policy</li> <li>a <code>set</code> command will modify attributes accordingly and pass all routes</li> </ul> <p>RPL has a number of operators to compare attributes:</p> <p><code>eq</code> - attribute numerically equal to specified value <code>le</code> / <code>ge</code> - attribute is numerically lower/greater or equal to the specified value <code>is</code> - attribute is equal to specified value. use this for nonnumerical values <code>in</code> - attribute is contained in a value set</p> <p>Then RPL has many attribute-specific operators, like AS path matching.</p> <p>Also basic boolean operators: <code>AND</code>, <code>OR</code>, <code>NOT</code></p> <p>An example: <pre><code>route-policy transit-LocalPref\n  if med eq 10 and not local-preference eq 100 then\n    set local-preference 300\n  elseif med eq 20 or local-preference eq 200 then\n    set local-preference 200\n  else\n    set local-preference 150\n  endif\nend-policy\n</code></pre></p> <p>There are two types of nesting characteristics: </p> <ol> <li> <p>Nesting conditional statements <pre><code>route-policy OuterRP\n  if med eq 10 then\n    if local-preference eq 200 then\n      set community (1:10) additive\n    endif\n  endif\nend-policy\n</code></pre></p> </li> <li> <p>Nested hierarchical  <pre><code>route-policy Set10C\n  if local-preference eq 100 then\n    set community (1:10) additive\n  endif\nend-policy\n\n\nroute-policy MatchMED\n  if med eq 10 then\n    apply Set10C\n  endif\nend-policy\n</code></pre></p> </li> </ol>"},{"location":"Routing%20Policy/#rpl-attributes-and-parameters","title":"RPL Attributes and Parameters","text":"<p>Within RPL, to assign values to attributes and parameters, use <code>set</code>. There are some intricacies that are important when building RPL:   </p> <p>All <code>set</code> statements are processed upon completion of the route-policy.</p> <p>The last applied <code>set</code> wins if they match against the same unique parameter, such as local preference</p> <p>For non-unique parameters, like AS-path, all <code>set</code> commands are evaluated in order</p> <p>When working with communities, remember that:</p> <ul> <li>You can assign one or more values to the BGP community attribute</li> <li>If you use <code>additive</code>, new communities are added to existing BGP community attribute</li> <li>If you do not use `addititive, then existing BGP communities are overwritten </li> <li><code>delete</code> let's you delete some or all BGP community attributes</li> </ul> <p>Some other commonly used <code>set</code> commands with BGP:</p> <p><code>set local-preference [*|+|-] (value)</code> - syntax for setting local-pref</p> <p><code>set med {[+|-] value | igp-cost | max-reachable}</code> - for setting multi-exit discriminator (med)</p> <p><code>set dampening [halflife value] [max-suppres value] [reuse value] [suppress value]</code> - route-flap dampening</p> <p><code>prepend as-path {AS | most-recent | own-as} [count]</code> - AS-path prepending</p> <p><code>suppress-route</code> - used when doing route aggregation, will suppress if aggregated</p> <p><code>unsuppress-route</code> - same as above, will unsuppress if agg</p>"},{"location":"Routing%20Policy/#ospf-and-is-is-attributes-and-parameters-using-rpl","title":"OSPF and IS-IS attributes and parameters using RPL","text":"<p>These OSPF parameters can be modified with <code>set</code>:</p> <p><code>set metric-type {type 1|type 2}</code> to change the OSPF metric type <code>set ospf-metric [value]</code> to modify the OSPF metric <code>set tag [value]</code> to tag OSPF routes</p> <p>These IS-IS parameters can be modified:</p> <p><code>set metric-type {external|internal}</code> to change IS-IS metric type  <code>set isis-metric [value]</code> to set the IS-IS metric <code>set level {level-1 | level-2 | level-1-2}</code> to set IS-IS level for redistributed routes <code>set tag [value]</code> to tag IS-IS routes</p>"},{"location":"Routing%20Policy/#rpl-parameterization","title":"RPL Parameterization","text":"<p>Use parameters to make your RPL configs modular and more readable. You can re-use parameters globally and within individual policies/nested policies.</p> <p>You can also \"pass\" parameters into a nested routing policy, both using global parameters and nested routing policies</p> <p>Global parameters are defined with <code>policy-global</code>, and they'll be available for all policies to use.</p> <p>If there is a global and local parameter name \"collision\" then the local parameter takes precendence.</p> <p><pre><code>policy-global\n  # global vars\n  AS '65001',\n  Lo0 '10.100.70.1',\n  EBGP1 '192.168.2.1',\n  EBGP2 '192.168.3.1',\n  upstream-weight '5',\n  upstream-LP '100',\n  DefMED '0'\nend-global\n</code></pre> <pre><code>route-policy Set-Upstream\n  if as-path originates-from '$AS' then\n    set med $DefMED\n  endif\nend-policy\n</code></pre></p>"},{"location":"Routing%20Policy/#characteristics-of-the-rpl-passed-parameters","title":"Characteristics of the RPL passed parameters:","text":"<ul> <li>Declare parameters when creating a routing policy.</li> <li>Nesting policies with parameters allows for greater modularization and optimization of policies.</li> </ul> <p><pre><code>route-policy SetMED($med,$as)\n  if as-path originates from '$as' then\n    set med $med\n  else\n    set med max-reachable\n  endif\nend-policy\n!\n</code></pre> <pre><code>route-policy ProcessUpdates\n  if as-path neighbor-is '1299' then \n    apply SetMED(50,1299)\n  elseif as-path neighbor-is '6939' then\n    apply SetMED (100,6939)\n  endif\nend-policy\n!\n</code></pre></p>"},{"location":"Routing%20Policy/#value-sets","title":"Value Sets","text":"<p>In general programming sense, a <code>set</code> is an unordered collection of unique elements. </p> <p>RPL provides sets as containers for groups of values for matching purposes. </p> <ul> <li>Used in conditional expressions for matching</li> <li>You can create inline sets for one-time use</li> <li>You can create named sets for reusability</li> </ul> <p>There are 5 kinds of sets:</p> <ol> <li>AS-path set <code>as-path-set</code><ul> <li>An AS path set can contain one or more regex paths, like <code>ios-regex ^7922_10999</code></li> </ul> </li> <li>Community set <code>community-set</code></li> <li>Extended community set <code>extcommunity-set</code></li> <li>Prefix set <code>prefix-set</code></li> <li>Route distinguisher (RD) set <code>rd-set</code></li> </ol> <p>In-line set example: <pre><code>route-policy RP-inline-example\n  if attribute in (value1, value2, ...)\nthen\n  set local-preference 150\nendif\nend-policy\n</code></pre></p> <p>Named set example: <code>xy-set</code> is stand-in for any of the various types <pre><code>xy-set set-name\n  value1,\n  value2\nend-set\n!  \nroute-policy RP-named-example\n  if attr in set-name then\n    set local-preference 200\n  endif\nend-policy\n</code></pre></p> <p>AS-path Sets</p> <ul> <li>Can contain one or more AS path regex</li> </ul> <pre><code>as-path-set OutboundAvoids\n  ios-regex '_10$',   # originates-from path\n  ios-regex '^6939_',  # neighbor-is path\n  ios-regex '_174_',  # passes-through ASN\n  ios-regex '^3356_'  \n!\nroute-policy RP\n  if as-path in OutboundAvoids then\n    set local-preference 90\n  endif\nend-policy\n</code></pre> <p>Regex can be resource expensive, so alternatively, there are predefined AS path matching rules</p> <p><code>neighbor-is path</code>: matches based on first ASN in the AS path, same as regex '^path_\u2018</p> <p><code>originates-from path</code>: matches based on last ASN in the AS path, same as regex '_path$'</p> <p><code>passes-through ASN</code>: matches based on ASN anywhere in the AS path, same as regex  '_path_\u2018)</p> <p><code>length len</code>: matches AS paths based on number of ASNs in the path</p> <p><code>unique-len len</code>: matches AS paths based on number of unique ASNs in path</p> <ul> <li>These are used as condition statements in RP, like </li> </ul> <pre><code>if as-path originates-from '100' or as-path originates from '200' then\n  set local-preference 70\n</code></pre> <p>Standard Community Sets:</p> <p>A community set holds community values for matching against standard community values, which must be split in half and expressed as two unsigned decimal integers 0-65535, seperated by a colon. </p> <p>Characteristics:</p> <ul> <li>Defined as a global set with <code>community-set</code></li> <li>Use one or more comma-seperated match options in CLI<ul> <li><code>ios-regex</code> to define regex set membership</li> <li>numbered membership matching</li> <li>membership matching against well-known standard communities</li> </ul> </li> <li>use <code>match-any</code> operator to match routes that have at least one community in community set</li> <li>use <code>match-every</code> operator to match routes where every element of community set matches a community from the route</li> <li><code>matches-within</code> operator to match routes where every community from the route matches an element within the set</li> </ul> <p><pre><code>community-set MyComms\n  ios-regex '64998:10..'\n  ios-regex '64998:20..'\nend-set\n</code></pre> <pre><code>community-set MyComms2\n  ios-regex '64998:[12]0..'\nend-set\n</code></pre> <pre><code>route-policy Comm2LP\n  if community matches-any MyComms then\n    set local-preference 200\n  endif\nend-policy\n</code></pre></p> <p>Both examples <code>community-set</code>'s do the same thing. Also, ranges and wildcards can be used with community-set sets, like:</p> <p><code>ASN:num</code> <code>ASN:[range]</code> <code>ASN:*</code></p> <p>Also, well-known communities has identifiers:</p> <p><code>internet</code>: matches all communities I am still not entirely certain what this one is... the others are in RFC1997 but not this one? <code>local-as</code>: keeps tagged prefixes in the local AS <code>no-advertise</code>: prevents tagged prefixes from being advertised to any peer <code>no-export</code>: prevents tagged prefixes from being announced to EBGP peers</p> <p>like: <pre><code>router bgp 64998\n  address-family ipv4 unicast\n    redistribute connected route-policy NoExport\n!\nroute-policy NoExport\n  set community no-export\nend-policy\n!\n</code></pre></p> <p>Extended Community Sets:</p> <p>Same as standard community sets, except contains support for extended communities. It also supports named forms and inline forms. Generally there are 3 types of extended communities sets: <code>cost</code>, <code>soo</code>, <code>rt</code>.</p> <p>Characteristics:</p> <ul> <li><code>extcommunity-set {cost | rt | soo}</code> command</li> <li>Then use one or more comma-separated match options with <code>ios-regex</code> or numbered community membership matching</li> <li>use <code>match-any</code> operator to match routes that have at least one community in community set</li> <li>use <code>match-every</code> operator to match routes where every element of community set matches a community from the route</li> <li><code>matches-within</code> operator to match routes where every community from the route matches an element within the set</li> </ul> <pre><code>extcommunity-ext rt RtExtCommPolicy\n  ios-regex '6500[1..9]:10..',\n  65000:*\nend-set\n!\nroute-policy ExtCommPolicy\n  if extcommunity rt matches-any RtExtCommPolicy then\n    set local-preference 200\n  endif\nend-policy\n</code></pre> <p>A cost set is an extcommunity set used to store cost EIGRP Cost Community type extended community type communities An rt set is an extcommunity set used to store BGP Route Target (RT) extended community type communities A soo set is an extcommunity set used to store BGP Site-of-Origin (SoO) extended community type communities</p> <p>Prefix sets:</p> <p>A prefix-set holds IPv4 or IPv6 prefix match specifications. The most simple to understand. </p> <pre><code>prefix-set PrivatePrefixes\n  10.0.0.0/8 le 32\n  172.16.0.0/12 le 32\n  192.168.0.0/16 le 32\nend-set\n!\nprefix-set Core-loopbacks\n  172.16.1.0/24 eq 32\nend-set\n</code></pre> <p>rd set:</p> <p>An rd-set is used to create a set with route distinguisher (RD) elements. An RD set is a 64-bit value prepended to an IPv4 address to create a globally unique Border Gateway Protocol (BGP) VPN IPv4 address.</p> <pre><code>rd-set rdset1\n     10.0.0.0/8:*,\n     10.0.0.0/8:777,\n     10.0.0.0:*,\n     10.0.0.0:777,\n     65000:*,\n     65000:777\n  end-set\n</code></pre>"},{"location":"Routing%20Policy/#routing-policies-application-maintenance-monitoring-and-testing","title":"Routing Policies Application, Maintenance, Monitoring, and Testing","text":"<p>When building routing policy, it is important to clearly define requirements. Once business and long-term strategy have been defined and reviewed, you should use these 4 steps to create and apply policies:</p> <ol> <li>design routing policy</li> <li>configure routing policy (in a test env first as needed etc)</li> <li>test the policy, using <code>show</code> etc</li> <li>apply the policy if correct meeting expectations</li> </ol> <p>When applying route policies, you have to think about the specific routing protocol mechanics and where you can attach the policy. Such as:</p> <ul> <li>redistribution between any two protocols</li> <li>received or sent updates, depending on the limitations of routing protocols (i.e.-- OSPF and ABR's)</li> <li>origination of routes in BGP by using network statements or summarization</li> <li>injecting routes into the routing table from BGP</li> </ul> <p>On IOX-XR, when you configure and commit changes, it performs a validity check in two phases:</p> <ol> <li>basic syntax and value checking when actually hitting enter upon making changes</li> <li>then once you commit, policies and changes verified for a given attach point</li> <li>for example, if you configure OSPF metrics in a route-policy, you cannot attach it to a policy used for BGP neighbor-in filtering</li> </ol> <p><code>show rpl</code> or <code>show rpl &lt;$policy&gt; detail</code> or <code>show rpl &lt;$policy&gt; attachpoints</code>.</p> <p><code>show bgp route-policy &lt;$policy&gt;</code> can show filtered output for policies </p>"},{"location":"Routing%20Policy/#maintaining-route-policies","title":"Maintaining route policies","text":"<p>You cannot edit the routing policy directly with the CLI commands.</p> <ul> <li>Use available editors through exec mode, like <code>route-policy Upstream-BGP-IN</code> to create and being editing. <pre><code>RP/0/RP0/CPU0:P1# edit route-policy Upstream-BGP-IN ?\n  emacs  to use Emacs editor\n  nano   to use nano editor\n  vim    to use Vim editor\n  &lt;cr&gt;\n</code></pre></li> </ul>"},{"location":"Routing%20Policy/#route-maps-to-rpl","title":"Route Maps to RPL","text":"<p>You generally can map each numbered entry to an <code>if</code> statement, then each route-map <code>match</code> statement is an conditional (<code>if</code>, <code>elif</code>, <code>else</code> etc)</p> <p>Route maps with 2 <code>match</code> conditions of same type should be joined into a conditional with <code>OR</code> operator</p> <p>Route maps with 2 <code>match</code> conditions of different types should be joined into a condition with <code>AND</code> operator</p>"},{"location":"SR%20TE/","title":"SR Traffic Engineering","text":""},{"location":"SR%20TE/#sr-te-concepts-components-and-comparisons-to-rsvp-te","title":"SR TE Concepts, Components, and Comparisons to RSVP TE","text":"<p>SR-TE uses policy to steer traffic. An SR-TE policy path is expressed as a list of segments that specifies the path, called a segment ID (SID) list.</p> <p>Each segment is an e2e path from src to dst and instructs the routers in the network to follow the specified path instead of the shortest path calculated by the IGP. If or when a packet is steered into an SR-TE policy, the SID list is pushed onto the packet by headend. The rest of network executes the instructions in the SID list.</p> <p>There are two types of SR-TE policies: explicit and dynamic.</p>"},{"location":"SR%20TE/#differences-from-rsvp-te","title":"Differences from RSVP TE","text":"<p>TE state in RSVP is maintained by all nodes in the path by exchanging messages. In SR-TE, the state is only kept at the headend.</p> <p>SR-TE is designed with SDN in mind. A signaling protocol is unnecessary, so this scales better.</p> <p>The SR-TE model and SID list allow for IGP ECMP.</p>"},{"location":"SR%20TE/#sr-policy-concepts-constraints-metrics-and-attributes","title":"SR Policy Concepts, Constraints, Metrics, and Attributes","text":"<p>SR-TE offers a rich set of options to govern traffic engineering with metrics and constraints. Aka... knobs.</p> <p>The main components of SR-TE:</p> <p>Path determination: </p> <ul> <li>Who calculates the path? <code>Local</code> or <code>Central</code> -- done by headend node or PCE?</li> <li>Based on what? <code>Metrics</code> (cost, latency, bw, etc) or <code>Constraints</code> (color, affinity, node, etc)</li> </ul> <p>Steering determination:</p> <ul> <li>Who determines the policy? <code>Local</code> or <code>Central</code></li> <li>How is the policy created? static, autoroute, BGP SR-TE dynamic, etc</li> </ul> <p>SR-TE uses policy to steer traffic through the network.</p> <ul> <li>Avoids the use of tunnel in context, since most policies do not require tunnel-te interfaces</li> <li>Tunnel interfaces deprecated</li> <li>SR-TE policy path is expressed as a SID-list </li> <li>A packet is steered into SR-TE policy, then a SID list is pushed onto the packet by headend, while the rest of the network executes the instructions in the SID list (source routing)</li> </ul> <p>Binding segment is fundamental building block. It is a local segment identifying a SR-TE policy. Each SR-TE policy is 1:1 with a binding SID.</p> <ul> <li>Binding SID is used to steer traffic into a SR-TE policy<ul> <li>The instruction associated with a binding SID is \"POP and steer into this SR-TE policy\"</li> </ul> </li> <li>The Binding SID is a local label, statically or dynamically allocated for each SR-TE policy...<ul> <li>they can be manually configured, per policy in some cases</li> <li>they can be allocated for RSVP-TE tunnels </li> <li>they are allocated when SR-TE policy is instantiated </li> <li>if you bring down SR-TE policy, binding SID remains</li> </ul> </li> </ul> <p>SR-TE offers comprehensive support for all useful optimizations and constraints:</p> <ul> <li>Latency</li> <li>Bandwidth</li> <li>Disjointedness</li> <li>Resource avoidance</li> <li>Weighted balancing</li> </ul> <p>Then it can use </p> <ul> <li>IGP metric</li> <li>TE metrics: <code>administrative distance</code></li> <li>Delay as link-delay metric automatically measured by a node for attached links and distributed into IGP</li> </ul> <p>Margins: can be configured to relax the \"absolute\" Min-Metric objective to favor more ECMP behavior.</p> <ul> <li>Headend builds SID list such that packets flowing through it do not use a path whose cumulated optimized metric is larger than the shortest path for the optimized metric + margin.</li> <li>Margin can be expressed as an absolute value or as a relative value (percentage) (margin relative &lt;%&gt;).</li> </ul> <p>Constraints used by SR-TE: - TE affinity - IP addresses - SRLG (??) - Max accumulated metric (IGP, traffic engineering, and delay) - Max number of SIDs in the solution SID list. - Disjoint from another SR policy in the same association group</p>"},{"location":"SR%20TE/#distribution-of-policies","title":"Distribution of policies","text":"<p>SR-TE can be deployed locally or centrally. \"Centralized\" does not necessarily mean a complete state-of-the-art SDN controller. It may be simply a conventional stateful path computation element (PCE) running on a physical or virtualized router.</p>"},{"location":"SR%20TE/#sr-te-traffic-steering","title":"SR-TE Traffic Steering","text":"<p>The path computation element protocol (PCEP) describes a set of procedures by which a path computation client (PCC) can report and delegate control of head-end label switched paths (LSPs) sourced from the PCC to a PCE peer.</p> <p>The stateful model also enables a PCC to ask a PCE to perform computations to perform network-wide orchestration.</p> <p>The binding SID (BSID) is the primary TE mechanism</p> <ul> <li>Locally programmed via BGP SR-TE dynamic:<ul> <li>destination or flow based</li> </ul> </li> <li>Remotely programmed<ul> <li>\"nesting\" or \"stiched\" SR-TE policies</li> </ul> </li> <li>Classic mechanisms with static routes, autoroute, PBTS (?), others can be used but not preferred (also likely half broken)</li> </ul> <p>The BSID allows for</p> <ul> <li>Scalability</li> <li>Multidomain support</li> <li>Service-aware</li> <li>Data plane performance</li> <li>Loop-free network path</li> <li>Binding SID acting as the encapsulation key</li> <li>Automation and simplification using On-Demand Next Hop (ODN)</li> </ul> <p>Policy instantiation is much easier compared to RSVP. Created an on-demand policy with a specific color, and it can dynamically generate a path to specified endpoint, such as L3VPN.</p>"},{"location":"SR%20TE/#bgp-sr-te-steering","title":"BGP SR-TE Steering","text":"<p>Summary and examples...</p> <p>Trigger automatic SR-TE policies for traffic to BGP destination - Policies to meet SLAs, latency-optmized or other etc</p> <p>Set at egress PE by adding a color-extended community to the router: - color extended communitiy propagated to ingress PE - traffic steering on ingress PE occurs automatically, based on the color, no routing policies in BGP required</p> <p>Because the SID list associated with the policy is programmed into the hardware, there are no software-based recursive lookups causing a delay in the forwarding of traffic.</p> <p><code>show bgp</code> table can show <code>Colored Prefixes</code> in the next-hop column.</p> <p><code>show bgp x.x.x.x</code> will show <code>SR Policy Color</code> <code>BSID</code> associated as well.</p>"},{"location":"SR%20TE/#sr-pce-based-paths","title":"SR PCE-Based Paths","text":"<p>SR-TE was built around a SDN-like or SDN controller computing TE paths and communicating policies to headend routers.</p> <p>The PCE does:</p> <ul> <li>Compute path and optionally...</li> <li>Steer traffic into policy</li> </ul> <p>The PCC's can be stateful or stateless connecting with the PCE.</p> <p>PCEP is the protocol/communication channel between the PCE and PCC.</p> <p>If a PCE is operating as stateful, it has an additional database called LSP DB, while in both stateful and stateless modes, it has the TED or traffic engineering database.</p> <p>The headend router can connect with the PCE to request a SR-TE policy for a LSP based on metrics and constrains provided by the PCC. If the PCC requires further changes to the policy, it will re-request the PCE to compute a new path, but each transaction is a single transaction. This is the <code>stateless</code> model. </p> <p><code>Stateful</code> PCE maintains an active topology of the network via BGP-LS, where the PCC reports to the PCE any topology changes. </p> <p>The path computation element protocol (PCEP) describes a set of procedures by which a path computation client (PCC) can report and delegate control of head-end label switched paths (LSPs) sourced from the PCC to a PCE peer.</p> <p></p> <p>(these definitions are from PCEP RFC 5440)</p> <p>PCReq: a PCEP message sent by a PCC to a PCE to request a path computation.</p> <p>PCRep: a PCEP message sent by a PCE to a PCC in reply to a path computation request.  A PCRep message can contain either a set of computed paths if the request can be satisfied, or a negative reply if not.  The negative reply may indicate the reason why no path could be found.</p> <p>In the stateful PCE setup process:</p> <ol> <li>The PCC sends PCRequest</li> <li>PCE calculates path</li> <li>PCE sends PCReply</li> <li>PCC sets SR-TE policy</li> <li>PCC sends PCReport</li> <li>PCE updates LSP DB</li> </ol>"},{"location":"SR%20TE/#bgp-ls","title":"BGP-LS","text":"<p>Allows the stateful PCE to learn about the topology and SIDs in each domain. This gives the PCE a complete view of the network. </p> <p>The stateful PCE uses the topology and SID information to calculate and update paths in the network by using native SR-TE algorithms.</p> <p>In order for BGP-LS to learn about the topology and SID information from the IGP, the IGP itself, IS-IS or Open Shortest Path First (OSPF), must be configured to distribute the information to BGP-LS. </p> <p>If the PCE participates directly in the IGP domain, then the distribution of the IGP topology and SID information to BGP-LS can be configured directly on the PCE node. The PCE can operate similiarly to a route reflector, it can exist outside the data plane.</p>"},{"location":"SR%20TE/#configuring-pcep","title":"Configuring PCEP","text":"<p>Instead of a SDN controller or similiar, a router running IOS-XR can function as a PCE. The configuration is easy, enable <code>pce</code> in global config, then refer to an IP address that should be assigned to a Loopback interface.</p> IOS XR<pre><code>pce\n  address ipv4 1.1.1.10\n!\n</code></pre> <p></p> <p>On the PCE side of things, the config is under the <code>segment-routing</code> <code>traffic-eng</code> section. You need to specify the remote address of the PCE, and you can optionally configure a source address.</p> IOS XR<pre><code>segment-routing\n  traffic-eng\n    pcc\n      source-address ipv4 1.1.1.11\n    pce address ipv4 1.1.1.10\n    !\n  !\n</code></pre> <p>You can configure a precedence value if you configure multiple PCE's. Lower-precedence values are preferred. </p> <p>Verifying PCEP Sessions at the PCC... </p> <p><code>show segment-routing traffic-eng pcc ipv4 peer [brief]</code></p> <p>Then on PCE...</p> <p><code>show pce ipv4 peer</code></p>"},{"location":"Segment%20Routing/","title":"Segment Routing","text":""},{"location":"Segment%20Routing/#segment-routing-and-igps","title":"Segment routing and IGPs","text":"<p>Segment Routing (SR) is a flexible, scalable way of doing source routing. The source chooses a path and encodes it in the packet header as an ordered list of segments. Segments are identifier for any type of instruction. Each segment is identified by the segment ID (SID) consisting of a flat unsigned 32-bit integer. Segment instruction can be:</p> <ul> <li> <p>Go to node N using the shortest path</p> </li> <li> <p>Go to node N over the shortest path to node M and then follow links Layer 1, Layer 2, and Layer 3</p> </li> <li> <p>Apply service S</p> </li> </ul> <p>Segment routing is a more simple approach, probably. Instead of using LDP to pass MPLS labels and segments, we can use extensions to IS-IS and OSPF. </p>"},{"location":"Segment%20Routing/#is-is-modifications","title":"IS-IS modifications","text":"<p>TLV extensions to support prefix segment identifiers (SID's), adjacency SID's, and prefix-to-SID mapping advertisement. </p> <p>IS-IS has the following segment routing functionality:</p> <ul> <li>IPv4, IPv6 control plane</li> <li>Level 1, Level 2, and multilevel routing</li> <li>Prefix SIDs for host prefixes on loopback interfaces</li> <li>Adjacency SIDs for adjacencies<ul> <li>Nonprotected and protected SIDs</li> </ul> </li> <li>Prefix-to-SID mapping advertisement (mapping server)</li> <li>MPLS penultimate hop popping (PHP) and explicit-null signaling</li> </ul>"},{"location":"Segment%20Routing/#ospf-modifications","title":"OSPF modifications","text":"<p>OSPF extensions have been added in order to provide the necessary support for segment routing, including prefix segment identifiers, adjacency segment identifiers, and prefix-to-SID mapping advertisements.</p> <p>OSPF segment routing functionality extensions:</p> <ul> <li>OSPFv2 control plane</li> <li>OSPF extensions</li> <li>Multi-area</li> <li>IPv4 prefix segment ID (prefix SID) for host prefixes on loopback interfaces</li> <li>Adjancency segment (adj-SID) for adjancencies, nonprotected and protected adj-SIDs</li> <li>MPLS PHP and explicit-null signaling</li> </ul> <p>OSPF adds to the Router Information Opaque LSA type 4-- SR-algo TLV (8) and SID/Label range TLV (9).</p> <p>Also, it defines new OSPFv2 Extended Prefix Opaque LSA type 7 and Extended Link Opaque LSA type 8.</p>"},{"location":"Segment%20Routing/#segment-routing-labels","title":"Segment Routing Labels","text":"<p>Segment Routing Global Block (SRGB) is the range of labels reserved for SR Global Segments in the Label Information Database (LIB) or Label Switching Database (LSD). These values are assigned as SIDs to SR-enabled nodes. On SR-capable routers, SRGB is enabled by default so that label values are auto-reserved when the router boots, whether or not it is used/enabeld.</p> <p>By default, this is 16000-24999. </p> <p>Segment Routing Local Block (SRLB) is a range of label values preserved for the manual allocation of adjacency segment identifities (adj-SIDs). These are locally significant, only valid on the local node 15000-15999.</p> <p>A prefix-SID is advertised as a domain-wide unique index, which then refers to a unique label within the SRGB.</p> <ul> <li>Index is zero based, i.e. first index = 0 \u2013 Label = Prefix-SID index + SRGB base \u2013 E.g. Prefix 1.1.1.65/32 with prefix-SID index 65 gets label 16065</li> </ul>"},{"location":"Segment%20Routing/#is-is-and-the-srgb","title":"IS-IS and the SRGB","text":"<ul> <li>The SRGB is advertised via IS-IS Router Capabilities TLV<ul> <li>Contains the router-ID, flags (Scope (<code>S</code>) indicates flood TLV across routing domain, Down (<code>D</code>) if TLV is leaked from L2 to L1), then optional sub-TLV's</li> </ul> </li> <li>SR Capabilities sub-TLV is included in the Router Capabilities TLV</li> <li>SR Capabilities sub-TLV contains flags and one or more SRGB descriptors<ul> <li>Then... SRGB descriptor contains the range, and the SID/label, indicating a start of SRGB</li> <li>SR-Capabilities sub-TLV flags could be <code>I</code> for outoing IPv4 encapsulation or <code>V</code> for outgoing IPv6 encap.</li> </ul> </li> </ul>"},{"location":"Segment%20Routing/#ospf-and-srgb-in-lsas","title":"OSPF and SRGB in LSAs","text":"<p>The OSPF Router Information Opaque LSA carries information about the SRGB, including the range, size, and start of the SRGB:</p> <ul> <li>the SRGB descriptors is included in the Router Info Opaque LSA type 4 LSA<ul> <li>the SR algorithm TLV (8), which will be <code>algo 0: Shortest Path First (SFP)</code> based on link metric</li> <li>the SID/label range TLV (9)</li> </ul> </li> </ul> <p></p>"},{"location":"Segment%20Routing/#sr-is-is-configuration","title":"SR IS-IS Configuration","text":"<p>SR with IS-IS is enabled per address-family, and it will be enabled on all nonpassive IS-IS interfaces. </p> <p>Adjacency SIDs are allocated and distributed for all adjacencies for both nonprotected adjacency SIDs and protected adjacency SIDs, using Segment Routing Traffic Engineering (SR-TE).</p> IOS XR<pre><code>!\nrouter isis 1\n  address-family ipv4 unicast\n    metric-style wide\n    segment-routing mpls\n  !\n    address-family ipv6 unicast\n    metric-style wide\n    segment-routing mpls\n  !\n  interface Loopback0\n    passive\n    address-family ipv4 unicast\n      prefix-sid absolute 16001\n    !\n    address-family ipv6 unicast\n      prefix-sid absolute 20001\n  !\n  interface TenGigE0/2/0\n    point-to-point\n    address-family ipv4 unicast\n    !\n    address-family ipv6 unicast\n</code></pre> <ul> <li>A prefix segment identifier (SID) is associated with an IP prefix. </li> <li>The prefix SID is manually configured from the segment routing global block (SRGB) range of labels. </li> <li>A prefix SID is configured under the loopback interface with the loopback address of the node as the prefix. </li> <li> <p>The prefix segment steers the traffic along the shortest path to its destination. </p> </li> <li> <p>An adjacency SID (Adj-SID) is associated with an adjacency to a neighboring node. </p> </li> <li>The adjacency SID steers the traffic to a specific adjacency. </li> <li>Adjacency SIDs have local significance and are only valid on the node that allocates them. </li> </ul> <p>To verify IS-IS capabilities, you can use a few commands...</p> <p><code>show isis database verbose</code> to examine the IS-IS link-state database to look at SR descriptors for propagated info.</p> <ul> <li>Further in this command, you can look at the prefix-SID advertisements which are via the IPv(4|6) reachability TLV</li> </ul> <p></p> <p><code>show isis database verbose</code> will show LAN-adjacency label advertisements, then you can look at the local label value (the LAN-ADJ-SID), such as 24001, which is allocated dynamically by default from the SRLB.</p> <ul> <li>If you were to look at <code>show mpls forwarding</code>, the local label would correspond to the LAN-AJD-SID.</li> </ul>"},{"location":"Segment%20Routing/#sr-ospf-configuration","title":"SR OSPF Configuration","text":"<p>If OSPF is enabled for SR, it will be enabled on all interfaces also enabled for OSPF. Then Adjacency-SIDs will be allocated and distributed for SR-enabled adjacencies.</p> IOS XR<pre><code>!\nrouter ospf 1\n  segment-routing mpls\n  segment-routing forwarding mpls\n  router-id 1.1.1.1\n  area 0\n    interface Loopback0\n      passive enable\n      prefix-sid absolute 16001\n    !\n    interface GigE0/0/0/0\n      network point-to-point\n    interface GigE0/0/1/1\n\n!\n</code></pre> <ul> <li>OSPF supports a hierarchical model: Instance&gt;Area&gt;Interface<ul> <li>If enabled at a higher level, inherited down</li> </ul> </li> </ul> IOS XR<pre><code>!\nrouter ospf 1\n  area 0\n    segment-routing mpls\n    segment-routing forwarding mpls\n    interface GigE0/0\n      segment-routing forwarding disable\n!\n</code></pre> <p>To verify OSPF SR capabilities, <code>show ospf database</code> is used and <code>self-originate originate</code> option is helpful</p> <p></p> <p>Then you'd want to narrow down on specific Type 4 LSA, like <code>show ospf database opaque-area 4.0.0.0 self-originate</code>, which will show the SR TLV's with capabilities information, like SRGB range, algo.</p> <p>We can look more closely at Type 7 LSA, like <code>show ospf database opaque-area 7.0.0.1 self-originate</code>, to examine prefix-sid advertisements or for Type 8 LSA, like <code>show ospf database opaque-area 8.0.0.4 self-originate</code> to see Adj-sid and TLV's. Including the <code>Label</code></p> <ul> <li>OSPF allocates an adjacency SID for each adjacency in the 2WAY state or higher.</li> <li>On a broadcast or NMBA network, a node advertises an <code>Adj-SID</code> by using the <code>Adj-SID sub-TLV</code> for its adjacency to the DR and advertises <code>Adj-SIDs</code> by using the <code>LAN Adj-SID</code> for other neighbors such as BDR and DR-OTHER on the network.</li> </ul> <p><code>show ip ospf neigh [4.4.4.4] detail</code> can show the Adj SID label too.</p>"},{"location":"Segment%20Routing/#sr-bgp-configuration","title":"SR BGP Configuration","text":"<p>If you want to use Border Gateway Protocol (BGP) with segment routing, you need to understand the changes to BGP and how to configure BGP for segment routing.</p> <p>The BGP prefix label index is an optional transitive BGP path attribute.</p> <p>The following example shows how to configure the SRGB, create a BGP route policy using a $SID parameter and set label-index attribute, and then associate the prefix-SID index to the node.</p> IOS XR<pre><code>RP/0/RSP0/CPU0:router(config)# segment-routing global-block 16000 23999\n\nRP/0/RSP0/CPU0:router(config)# route-policy SID($SID)\nRP/0/RSP0/CPU0:router(config-rpl)# set label-index $SID\nRP/0/RSP0/CPU0:router(config-rpl)# end policy\n\nRP/0/RSP0/CPU0:router(config)# router bgp 1\nRP/0/RSP0/CPU0:router(config-bgp)# bgp router-id 10.1.1.1\nRP/0/RSP0/CPU0:router(config-bgp)# address-family ipv4 unicast\nRP/0/RSP0/CPU0:router(config-bgp-af)# network 10.1.1.3/32 route-policy SID(3)\nRP/0/RSP0/CPU0:router(config-bgp-af)# allocate-label all\nRP/0/RSP0/CPU0:router(config-bgp-af)# commit\nRP/0/RSP0/CPU0:router(config-bgp-af)# end\n\nRP/0/RSP0/CPU0:router-NEIGHBOR# show bgp 10.1.1.3/32\nBGP routing table entry for 10.1.1.3/32\nVersions:\n  Process           bRIB/RIB  SendTblVer\n  Speaker                 74          74\n    Local Label: 16003\nLast Modified: Sep 29 19:52:18.155 for 00:07:22\nPaths: (1 available, best #1)\n  Advertised to update-groups (with more than one peer):\n    0.2 \n  Path #1: Received by speaker 0\n  Advertised to update-groups (with more than one peer):\n    0.2 \n  3\n    99.3.21.3 from 99.3.21.3 (10.1.1.3)\n      Received Label 3\n      Origin IGP, metric 0, localpref 100, valid, external, best, group-best\n      Received Path ID 0, Local Path ID 1, version 74\n      Origin-AS validity: not-found\n      Label Index: 3\n</code></pre> <p>In this <code>show bgp</code> output above, we see the <code>Label Index</code> and <code>Received Label</code> are the same, indicating ImplNull label, indicating PHP.</p> <p><code>show cef</code> will show locally assigned labels as well as labels swapped onto packet. In the <code>labels imposed</code> (swapped onto), there will be label to next-hop and BGP prefix-SID label. </p> <p><code>show mpls forwarding</code> to look at the data plane</p> <pre><code>RP/0/RSP0/CPU0:router_C# show mpls forwarding labels 24002 24003\nLocal  Outgoing    Prefix             Outgoing     Next Hop        Bytes       \nLabel  Label       or ID              Interface                    Switched    \n------ ----------- ------------------ ------------ --------------- ------------\n24002  Pop         No ID              Te0/3/0/0    192.168.1.2     0 \n24003  Pop         No ID              Te0/1/0/0    192.168.1.3     0  \n</code></pre>"},{"location":"Segment%20Routing/#sr-and-ldp-interworking-concepts","title":"SR and LDP Interworking Concepts","text":"<p>A.k.a, the migration.</p> <p>The MPLS architecture permits the concurrent use of LDP, Resource Reservation Protocol-Traffic Engineering (RSVP-TE), and segment routing. The label manager (Label Switching Database (LSD)) on the node ensures that the labels used by various label protocols dose not collide and that local labels are uniquely allocated and assigned.</p> <p>For the global segments, it is the operator's responsibility to ensure that each global segment is unique within the segment routing domain.</p> <p>MPLS - MPLS or MPLS - IP works fine, labels are unique within their own scope. </p> <p>However, there can be issues for multiple IP-to-MPLS entries (SR and LDP), which cannot coexist equally.</p> <p><code>segment-routing mpls sr-prefer</code> or (default) <code>segment-routing mpls</code> (LDP)</p> <p></p>"},{"location":"Segment%20Routing/#igp-sr-ldp-programming-fib","title":"IGP, SR, LDP Programming FIB","text":"<p>The IGP has its own database (containing SR descriptors), which is installed into the RIB. </p> <p>So for example, we have prefix lookup on 10.100.200.3/24, which is <code>Loc_label 16005</code> and <code>Out_label 16005</code> in the IGP. This is pushed to the RIB.</p> <p>The RIB forwards this to LDP/LSD, which provides LDP labels <code>Loc_label 24005</code> and <code>Out_label 24006</code> and sends to the FIB.</p> <p>The RIB also forwards the IGB prefix path and IGP-provided SR labels to the FIB.</p> <p>By default, the FIB will prefer LDP-based label imposition, so the LDP labels are installed in cef.</p>"},{"location":"Segment%20Routing/#migration-methods","title":"Migration methods","text":"<p>A simultaneous deployment model can be used as a step in the simple migration from LDP to segment routing.</p> <ol> <li>Upgrade all nodes to support SR, then leave default LDP label imposition preference</li> <li>PE routers re-configured to prefer SR label imposition <code>segment-routing mpls sr-prefer</code></li> <li>LDP is removed from nodes in the network</li> </ol> <p>?? Probably others -- explore more since test says \"Migration procedures (SR prefer and mapping server)\"</p>"},{"location":"Segment%20Routing/#sr-mapping-server-function-and-config","title":"SR Mapping Server Function and Config","text":"<p>The mapping server advertises prefix-to-prefix-SID mappings on behalf of non-SR capable nodes. This action is necessary to enable interworking between SR and non-SR (LDP only) nodes.</p> <p>A router must be able to act as a mapping server, a mapping client, or both. </p> <p>At steady state, all routers, at least in the same area or level, must have identical active mapping policies.</p> <p>Mapping Server functionality:</p> <ul> <li>Advertise prefix-to-SID mappings in IGP to non-SR capable nodes</li> <li>Prefix-to-SID mappings are configured on the mapper server</li> <li>Enable SR-capable nodes to interwork w/ LDP nodes</li> </ul> <p>Similiar to a Route Reflector:</p> <ul> <li>Control plane mechanism</li> <li>Does not have to be in the data plane</li> <li>Must be resilient and redundancy should be provided</li> </ul> <p>The Mapping Client functions:</p> <ul> <li>Receive and parse prefix-to-SID mappings from server(s)</li> <li>Use remotely learned and locally configured mappings for a valid and consistent active SID mapping policy.</li> <li>Mappings not selected for active policy go to backup policy.</li> <li>By default, mapping client functionality is enabled. </li> </ul> <p>Prefix SIDs received from a mapping server have an implicit PHP-off behavior: The penultimate hop does not pop the prefix SID label.</p> <p>Packets arrive at the destination with prefix SID label on top...</p> <ul> <li>Packet with local prefix SID as top label would require two label lookups at the receiving node to forward packet: top-label lookup, pop top-label, next-label, or address lookup performance impact.</li> <li>In Cisco IOS XR Software, no MPLS forwarding entry is installed for local prefix SIDs. Packets with local prefix-SID as top label are dropped. </li> </ul>"},{"location":"Segment%20Routing/#configuring-mapping-server","title":"Configuring Mapping Server","text":"<p>IOS XR<pre><code>RP/0/RSP0/CPU0:router(config)# segment-routing\nRP/0/RSP0/CPU0:router(config-sr)# mapping-server\nRP/0/RSP0/CPU0:router(config-sr-ms)# prefix-sid-map\nRP/0/RSP0/CPU0:router(config-sr-ms-map)# address-family ipv4|ipv6\n\n# ip-address/ prefix-length first-SID-value range range \nRP/0/RSP0/CPU0:router(config-sr-ms-map-af)# 10.1.1.1/32 10 range 200 \n</code></pre> Prefix 10.1.1.1/32 is assigned prefix-SID 10, prefix 10.1.1.2/32 is assigned prefix-SID 11,\u2026, prefix 10.1.1.199/32 is assigned prefix-SID 200 </p> <p>On the mapping server, to verify locally configured--  <code>show segment-routing mapping-server prefix-sid-map [ipv4 | ipv6] [detail]</code></p> <p>You must additionally do some sort of routing protocol IGP configuration too...</p> IOS XR<pre><code>!\nrouter isis 1\n  address family ipv4|ipv6 unicast\n    segment-routing prefix-sid-map advertise-local\n\n\n!\nrouter ospf 1\n  segment-routing prefix-sid-map advertise-local\n</code></pre> <p>If the mapping server is a Level 1 or Level 2 router in IS-IS or an Area Border Router (ABR) in OSPF, the mappings will be advertised in all levels or areas of the IGP instance.</p> <p>On mapping clients, the default behavior is <code>segment-routing prefix-sid-map receive</code>, you can configure both or only <code>advertise-local</code>. A common sense design is like Route Reflectors, each node should be a mapping client to receive the prefix-to-SID mappings that it would not otherwise receive through the link-state advertisement from the non-SR nodes.</p>"},{"location":"Segment%20Routing/#ti-lfa-for-sr","title":"TI-LFA for SR","text":"<p>Topology Independent Loop-Free Alternate (TI-LFA)</p> <p>This is a fast reroute feature, that precomputes a backup path via the IGP. TI-LFA composes the list of segments necessary to steer the traffic a the backup path along the post-convergence path.</p> <p>The post-convergence path is the path that will be used after IGP has converged following a failure.</p> <p>This was not possible pre-SR, since SR enforces the post-convergence path as a list of segments. </p> <p>Uses existing and proven LFA technology and terminology (mostly my own words here, RFC7490 too)</p> <ul> <li>protected link L is more or less than current shortest path or \"best link vulnerable to failure\"</li> <li>P space is set of nodes reachable (using pre-convergence paths) from node S without using protected link L<ul> <li>there will be a \"point on the network\" that will be \"beyond the horizon\" aka never utilized due to the Shortest Path Tree between S and D because the protected link will always be Shortest Path to get \"over the horizon\". </li> </ul> </li> <li>Q space is a set of nodes that can reach (using pre-convergence paths) destination D without using protected link L<ul> <li>the \"other side of the horizon\"</li> </ul> </li> <li>P node: any node that is only in P space.</li> <li>Q node: any node that is only in Q space.</li> <li>PQ node: a node that is a member of both the extended P-space and the Q-space.</li> </ul> <p>Generalizes the name of nodes on the backup path:</p> <p>\u2013 P-node: node reached via a Prefix-SID \u2013 Q-node: node reached via an Adj-SID</p>"},{"location":"Segment%20Routing/#configuring-ti-lfa","title":"Configuring TI-LFA","text":"<p>IS-IS configuration is per interface, and both commands are required for TI</p> IOS XR<pre><code>router isis 1\n  interface Gi0/0/0/2\n    address family ipv4|ipv6 unicast\n      fast-reroute per-prefix\n      fast-reroute per-prefix ti-lfa\n</code></pre> <p>OSPF configuration can utilize OSPF inheritance (instance&gt;area&gt;interface).</p> IOS XR<pre><code>router ospf 1\n  fast-reroute per-prefix\n  fast-reroute per-prefix ti-lfa\n</code></pre> <p>In a <code>zero-segment</code> backup path, the Source node sends packet to alternative node without any additional segment. Since once alternative node receives the packet (and flow), it can forward to the destination with already tagged prefix-SID label. </p> <p>In a <code>single-segment</code> backup path, the Source node sends the packet to alternative node with an additional segment to enable the next node to push the segment to the next next node can forward to destination with existing prefix-SID label.</p> <p>When looking at <code>show isis ipv4 fast-reroute x.x.x.x/32 detail</code>, you'll see the label stack showing original destination prefix-SID label + single segment label.</p> <p>For OSPF with <code>show ospf 1 routes x.x.x.x/32 backup-path</code>, you see the \"two-hop\" P-node (R4 in example screenshot) and associated label.</p> <p>In <code>double-segment</code> backup path, the Source node sends the packet to alternative node with 2 additional segments to enable final P node to forward packets into Q space with existing prefix-SID labels.</p> <p>When looking at <code>show ospf 1 routes x.x.x.x/32 backup-path</code>, it will show both P and Q node router-ID's with their associated labels, aka double-segment. </p>"},{"location":"Segment%20Routing/#sr-ti-lfa-for-ldp","title":"SR TI-LFA for LDP","text":"<p>SR and TI-LFA can be incrementally deployed, and in the areas where they are deployed, they provide guaranteed protection also for LDP traffic. </p> <p>TI-LFA protection uses the SR/LDP interworking functionality.</p> <ul> <li>FIB uses label merging functionality for backup path</li> <li>Using LDP labels instead of SR labels where possible</li> </ul> <p>The mapping server advertises prefix-to-SID mappings for prefixes without prefix SID that must be protected (as show in screenshot below at the top).</p> <p>When looking at <code>show mpls ldp bindings $destination_Z</code>, you'll see 2 destination labels. Then you can easily look at <code>show cef $dest_Z</code> to identify which is backup and protected.</p> <p>This example is from a LDP-only source to a LDP-only destination.</p> <p>Here is a good screenshot example from Cisco's segment-routing presentation:</p> <p>For double-segment TI-LFA with LDP, the adj-SID will be used to steer packet into Q space. </p> <p>Protecting LDP traffic with TI-LFA \u2013 Restrictions</p> <ul> <li>Point of Local Repair (PLR) must be SR-capable</li> <li>Protected destination must have an associated prefix-SID     \u2013 Advertised by itself if SR-capable     \u2013 Advertised by mapping server if not SR-capable</li> <li>Single-segment protection: PQ node must be SR-capable<ul> <li>If not, use rLFA, which requires targeted LDP session</li> </ul> </li> <li>Double-segment protection: P and Q nodes must both be SR-capable</li> </ul>"},{"location":"Segment%20Routing/#ti-lfa-and-sr-ldp-interworking","title":"TI-LFA and SR LDP Interworking","text":"<p>TI-LFA leverages SR/LDP interworking functionality if not all nodes on the backup path are SR enabled. </p> <p>The main characteristics of this is:</p> <ul> <li>LDP traffic is protected by TI-LFA</li> <li>When protecting LDP with TI-LFA, the backup path for LDP MPLS-to-MPLS uses LDP labels if they are available:<ul> <li>Not configurable via SR/LDP preference, like <code>sr-prefer</code></li> <li>LDP label can be available to reach P, PQ node</li> <li>LDP label can be available to reach destination D from PQ</li> </ul> </li> <li>When protecting SR w/TI-LFA, the backup path for SR MPLS-to-MPLS uses SR labels if the next hops is SR-capable.<ul> <li>P, Q, and PQ must be SR-capable and must advertise a prefix SID</li> <li>Destination must have a prefix SID</li> </ul> </li> <li>Labels in backup for IP-to-MPLS depend on configured LDP/SR preference (<code>sr-prefer</code>)</li> </ul> <p>So in our screenshot above, when on the PLR (node 1), we can examine the labels and backup paths with our previously used show commands like</p> <p><code>show isis fast-reroute 1.1.1.6/32</code> - we'd see IS-IS has no outgoing label for router 5. There is no segment instructions, but we will see the 16006 label for the prefix-SID 1.1.1.6/32</p> <ul> <li>IS-IS cannot provide an outgoing label for Node4 since the downstream neighbor Node5 is not SR enabled</li> <li>SR/LDP interworking will replace this missing label with the corresponding LDP label... which we can observe in <code>show mpls ldp bindings 1.1.1.6/32</code> the remote bindings for Node4. </li> <li>Then in <code>show cef 1.1.1.6/32</code>, we can see the label stack with <code>labels imposed [LDP interworked label] [SR prefix-SID label]</code></li> </ul> <p>The process for which TI-LFA and SR LDP interworking happens is... complex</p> <ul> <li>IF a PLR has LDP enabled and TI-LFA has a calc'd PQ node for backup, PLR sends targeted LDP hellos to that PQ.</li> <li>If PQ accepts the tLDP hellos, an LDP session is established between PLR and PQ</li> <li>If a PLR receives an LDP label for <code>$dest_prefix</code> from the PQ, it uses that label in backup path for LDP traffic</li> <li>SR/LDP inteworking mechanism works for all labels on the TI-LFA backup path:<ul> <li>if LDP sends an unlabeled entry to LSD and then IGP sends a valid label for the same entry to RIB, the valid IGB (SR) label is used in FIB</li> <li>if IGP sends an unlabeled entry to RIB and LDP sends a valid label for same entry to LSD, the valid LDP label is used in the FIB</li> </ul> </li> </ul>"},{"location":"Segment%20Routing/#sr-in-v6-overview","title":"SR in v6 Overview","text":"<p>SR in IPv6 environments can also use the IPv6 data plane for source routing in addition to the MPLS data plane. SRv6 can be a gradual migration with full backwards compatability. It can be IPv6 control + (MPLS or IPv6 data plane).</p> <p>SR-IPv6 allows IPv6 data plane networks to benefit from all features deployed over the years in MPLS networks:</p> <ul> <li>Traffic engineering</li> <li>VPNs</li> <li>Fast Reroute</li> </ul> <p>SR-IPv6 also enables a number of new features:</p> <ul> <li>Conduit</li> <li>Service chaining</li> <li>BGP traffic engineering</li> <li>BGP peer engineering</li> <li>Application engineered routing</li> </ul> <p>For SRv6, only the nodes that have to process the packet header must have SR-IPv6 data plane support. All other nodes are just plain IPv6 nodes. SRv6 uses RFC 2460 (redefined more or less in RFC8986 too) uses a new type of header called Segment Routing Heading (SRH).</p> <p>In the SRH and the IPv6 packet, there are several critical fields to know:</p> <p>Next header: an 8-bit field that indicates what the type of header immediately following the SRH. </p> <p>Hdr Ext Len: 8-bit unsigned integer. Defines the length of the SRH header in 8-octet units, not including the first 8 octets.</p> <p>Type: 4</p> <p>Segments Left: index, in the Segment List, of the current active segment in the SRH. Decremented at each segment endpoint. It is a list of 128-bit IPv6 addresses representing each segment of the path. The Segment List is encoded in the reverse order of the path: the last segment is in the first position of the list and the first segment is in the last position.</p> <p>First Segment: offset in the SRH, not including the first 8 octets and expressed in 16-octet units, pointing to the last element of the Segment List, that is if that contains the first segment of the path.</p> <p>Flags: 16 bits of flags. These flags are defined:</p> <ul> <li>bit-0: cleanup</li> <li>bit-1: rerouted packet</li> </ul>"},{"location":"Segment%20Routing/#sr-header-procedures","title":"SR Header Procedures","text":"<p>SRH behavior and processing depends on the type and capability of node:</p> <ul> <li>Source node</li> <li>Transit node:<ul> <li>Intrasegment transit node</li> <li>Non-SR intrasegment transit node</li> <li>Segment endpoint node</li> </ul> </li> </ul> <p>Source Node characteristics... a SRH is created with a <code>Segment List</code> encoded in reverse order of the path. <code>Segments Left</code> is set to <code>n</code>-1 where <code>n</code> = number of segments in segment link. Then <code>First Segment</code> field is n-1.</p> <ul> <li>The Destination Address (DA) of the packet is set as the first segment of the path (DA = Segment_List[Segments_Left])</li> <li>Then the packet is sent out to the first segment, aka, the DA. </li> </ul> <p>Non-SR transit nodes will use plain IPv6 forwarding, solely on IPv6 DA. Transparent and interoperable with legacy non-SR-capable nodes.</p> <p></p>"},{"location":"Segment%20Routing/#insertion-vs-encapsulation","title":"Insertion vs. Encapsulation","text":"<p>Header insertion at the source. </p> <ul> <li>Source originates the packet with SRH</li> <li>SRH is kept and used along the path, finally delivered to DA</li> <li>OR, optionally, the SRH may be removed prior to deliver </li> </ul> <p>Compare to header insertion at ingress:</p> <ul> <li>Source originates the packet without any SRH.</li> <li>SRH is inserted at ingress.</li> <li>SRH is removed prior to deliver the packet to the destination.</li> </ul> <p>And also compare to encapsulation at ingress:</p> <ul> <li>Source originates packet without any SRH</li> <li>Ingress encaps incoming packet into new outer IPv6 header + SRH</li> <li>Upon leaving SR domain, decap'd without outer SR header + SRH</li> </ul>"}]}